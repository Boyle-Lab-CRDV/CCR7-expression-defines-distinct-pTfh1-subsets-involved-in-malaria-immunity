---
title: "Tfh IBSM40"
author: "Damian Oyong"
date: "2023-08-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load libraries

```{r}
library(Seurat)
library(scRepertoire)
library(data.table)
library(dplyr)
library(tidyr)
library(gtools)
library(ggraph)
library(purrr)
library(tibble)
library(circlize)
library(viridis)
library(ggalluvial)
library(RColorBrewer)
library(ggpubr)
library(rstatix)
pacman::p_load(tidyr, dplyr, circlize)
```

## Import VDJ data and create scRepertoire df

Rename barcode column to match Seurat object data

```{r}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # This only works if you are using RStudio

file.names <- list.files(pattern = 'filtered_contig_annotations.csv', recursive = TRUE)
names <- list.files(path='VDJ')

file_seq <- 1:length(file.names)

if(any(grepl("*.csv", file.names))==TRUE){
  ibsm_tcr <- file.names %>% 
    lapply(., function(i){
      fread(input = i)
    }) %>%
    setNames(names)
}

ibsm_tcr <- ibsm_tcr[mixedsort(names(ibsm_tcr))]

ibsm_tcr <- ibsm_tcr %>%
  map2(., file_seq, ~mutate(.x, barcode = sub(1, .y, barcode)))

names <- names(ibsm_tcr)

ibsm_tcr <- combineTCR(ibsm_tcr,
                       samples = names,
                       removeNA = TRUE,
                       removeMulti = TRUE,
                       filterMulti = TRUE)

## Now we need to edit the barcode, delete everything before "v3_"

ibsm_tcr <- ibsm_tcr %>% 
  map(~.x %>% mutate(barcode = gsub(".*VDJ_","",barcode)))

# ibsm_tcr <- ibsm_tcr[mixedsort(names(ibsm_tcr))]
```

## Import Seurat

```{r}

## Latest 19 Dec 2023: USE "suerat_clusters"
ibsm <- readRDS('/Users/damian.oyong/Library/CloudStorage/OneDrive-BurnetInstitute/Burnet/Projects/PROJECT - Tfh IBSM40/Tfh.IBSM.2_REANNOTATION_POSTNORM_V2_200724.rds')

# # Update latest cell annotation (19 September 2023)
# ibsm_meta <- fread('/Users/damian.oyong/Library/CloudStorage/OneDrive-BurnetInstitute/Burnet/Projects/PROJECT - Tfh IBSM40/TfhIBSM_scType_res2.2_metadata_190923.csv') %>% 
#   select(., c("cellname", "seurat_clusters")) %>% 
#   column_to_rownames(., var = "cellname")

# Latest metadata had more cleaning of mitohi cells, delete cells that don't match
# ibsm <- AddMetaData(ibsm, metadata = ibsm_meta)
# ibsm <- subset(ibsm, subset = seurat_clusters != "NA")

```

## Combine VDJ and Seurat

```{r}
ibsm_rep <- combineExpression(ibsm_tcr, ibsm,
                              cloneCall="aa", 
                              proportion = FALSE,
                              cloneSize=c(Single=1, Small=5, Medium=20, Large=100, Hyperexpanded=500))

ibsm_rep@meta.data$seurat_clusters <-  factor(ibsm_rep@meta.data$seurat_clusters, 
                                              levels = c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17", "Tfh1.17", "Tfreg", "IFNI", 
                                                         "heatshock", "ribo", "cluster2", "cluster3"))

ibsm_rep@meta.data$alternative_clusters <-  factor(ibsm_rep@meta.data$alternative_clusters, 
                                              levels = c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17", "Tfh1.17", "Tfreg", "IFNI", 
                                                         "heatshock", "ribo", "cluster2", "cluster3"))

```

## This is the default cluster colors and orders

```{r}
cluster_col <- c("Tfh1" = "#9e0142", "Tfh1_CM" = "#f4a582", "Tfh2" = "#5e4fa2", 
                 "Tfh17" = "#66c2a5", "Tfh1.17" = "#e6f598", "Tfreg" = "#74add1", 
                 "IFNI" = "#8c510a", "heatshock" = "#bf812d", "ribosomal" = "#fee090", 
                 "cluster2" = "#01665e", "cluster3" = "#b2abd2")

cluster_orders <- c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17", "Tfh1.17", "Tfreg", "IFNI", "heatshock", "ribo", "cluster2", "cluster3")

donor_col <- c("donor0"="#d53e4f", "donor1"="#3288bd", "donor2"="#1a9850", "donor3" = "#c2a5cf")
```

```{r}
# # Label which cell contains either chain or both (Currently ignored)
# ibsm_rep@meta.data <- ibsm_rep@meta.data %>%
#   mutate(chain =
#            case_when(grepl("TRA", ibsm_rep@meta.data$CTgene) & grepl("_NA", ibsm_rep@meta.data$CTaa) ~ "Alpha",
#                      grepl("TRB", ibsm_rep@meta.data$CTgene) & grepl("NA_", ibsm_rep@meta.data$CTaa) ~ "Beta",
#                      grepl("TRA|TRB", ibsm_rep@meta.data$CTgene) ~ "Both")
#   )
```

## How many cells:TCR
```{r}
cell.prop <- ibsm_rep@meta.data %>% 
  mutate(TCR = case_when(is.na(CTaa) == TRUE ~ "No",
                         TRUE ~ "Yes"))

# cell.prop <- cell.prop %>% 
#   group_by(chain) %>%
#   summarise(n = n()) %>% 
#   # group_by(seurat_clusters) %>% 
#   mutate(total = sum(n)) %>% 
#   mutate(prop = n/total*100)

```

## Clonal frequency to send to Megan

```{r}
clone_freq <- ibsm_rep@meta.data %>% 
  select(CTaa, clonalFrequency) %>% 
  mutate(clonalFrequency = case_when(is.na(clonalFrequency) ~ sum(is.na(CTaa)),
                                     TRUE ~ clonalFrequency))

write.csv(clone_freq, file = "clone_frequency.csv")

```

## Create a barplot of clonal frequency
```{r}
clone_order <- rev(mixedsort(unique(filter(ibsm_rep@meta.data, !is.na(cloneSize))$cloneSize)))

ggplot(filter(ibsm_rep@meta.data, !is.na(cloneSize)), aes(x = cloneSize))+
  geom_bar(fill="white", colour = "black")+
  geom_text(stat='count', aes(label= ..count..), vjust=-1)+
  scale_x_discrete(limits = clone_order)+
  theme_classic()+
  labs(y = "Count")+
  theme(axis.title.x = element_blank())
ggsave("Figures/Clonal_frequency.pdf")

ibsm_rep@meta.data <- ibsm_rep@meta.data %>% 
  mutate(cloneN = case_when(clonalFrequency == 1 ~ "1",
                               clonalFrequency == 2 ~ "2",
                               clonalFrequency == 3 ~ "3",
                               clonalFrequency == 4 ~ "4",
                               clonalFrequency > 5 ~ ">5")) %>% 
  mutate(cloneN = factor(cloneN, levels = c('1','2','3','4','>5')))


ibsm_rep@meta.data <- ibsm_rep@meta.data %>% 
  mutate(cloneN2 = case_when(clonalFrequency == 1 ~ "Clone # (N=1)",
                               clonalFrequency > 1 ~ "Clone # (N>1)")) %>% 
  mutate(cloneN2 = factor(cloneN2, levels = c('Clone # (N=1)','Clone # (N>1)')),
         day = factor(day, levels = c("day0", "day8", "day16", "day36")))

RColorBrewer::brewer.pal(name = "Spectral", n = 11)

ggplot(filter(ibsm_rep@meta.data, !is.na(cloneN)), 
       aes(x = alternative_clusters, fill = cloneN))+
  geom_bar(colour = "black", position = position_stack(reverse = TRUE), linewidth = 0.3)+
  # geom_text(stat='count', aes(label= ..count..), vjust=-1)+
  # scale_x_discrete(limits = clone_order)+
  theme_classic()+
  # scale_fill_brewer(palette = "GnBu", direction = 1)+
  scale_fill_manual(values = c("grey","#ABDDA4", "#66C2A5", "#3288BD", "#5E4FA2"))+
  labs(y = "Count")+
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle=90))+
  facet_wrap(~day, nrow = 1)
ggsave("Figures/Clonal_Freq_byAnnot.pdf", height = 3.5, width = 8)


count_data <- ibsm_rep@meta.data %>%
  filter(!is.na(cloneN)) %>%
  group_by(day, donor_day, donor_id) %>% 
  count(cloneN2) %>% 
  mutate(day = factor(day, levels = c("day0","day8","day16","day36")))
p <- count_data %>% 
  group_by(cloneN2) %>% 
  wilcox_test(n ~ day, paired = F) %>% 
  add_y_position()
ggplot(count_data, aes(x = day, y = n)) +
  stat_summary(fun=sum, geom="bar", fill = "white", color = "black")+
  theme_classic() +
  # scale_fill_manual(values = c("grey","#ABDDA4", "#66C2A5", "#3288BD", "#5E4FA2")) +
  labs(y = "Count") +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 90)) +
  facet_wrap(~cloneN2) +
  stat_pvalue_manual(p, label = "p", hide.ns = "p")
ggsave("Figures/Clonal_N2.pdf")

```

## Barplot frequency separate
```{r}
ggplot(filter(ibsm_rep@meta.data, !is.na(cloneN) & alternative_clusters %in% c("Tfh1_CM","Tfh1","Tfh2","Tfh17")), 
       aes(x = alternative_clusters, fill = cloneN))+
  geom_bar(colour = "black", position = position_stack(reverse = TRUE), linewidth = 0.3)+
  # geom_text(stat='count', aes(label= ..count..), vjust=-1)+
  # scale_x_discrete(limits = clone_order)+
  theme_classic()+
  # scale_fill_brewer(palette = "GnBu", direction = 1)+
  scale_fill_manual(values = c("grey","#ABDDA4", "#66C2A5", "#3288BD", "#5E4FA2"))+
  labs(y = "Count")+
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle=90))+
  facet_wrap(~day, nrow = 1)
ggsave("Figures/Clonal_Freq_byAnnot_Tfh.pdf", height = 3.5, width = 8)

ggplot(filter(ibsm_rep@meta.data, !is.na(cloneN) & !alternative_clusters %in% c("Tfh1_CM","Tfh1","Tfh2","Tfh17")), 
       aes(x = alternative_clusters, fill = cloneN))+
  geom_bar(colour = "black", position = position_stack(reverse = TRUE), linewidth = 0.3)+
  # geom_text(stat='count', aes(label= ..count..), vjust=-1)+
  # scale_x_discrete(limits = clone_order)+
  theme_classic()+
  # scale_fill_brewer(palette = "GnBu", direction = 1)+
  scale_fill_manual(values = c("grey","#ABDDA4", "#66C2A5", "#3288BD", "#5E4FA2"))+
  labs(y = "Count")+
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle=90))+
  facet_wrap(~day, nrow = 1)
ggsave("Figures/Clonal_Freq_byAnnot_nonTfh.pdf", height = 3.5, width = 8)
```


## Barplot frequency separate >2 clones
```{r}
ggplot(filter(ibsm_rep.expanded@meta.data, !is.na(cloneN) & alternative_clusters %in% c("Tfh1_CM","Tfh1","Tfh2","Tfh17")), 
       aes(x = alternative_clusters, fill = cloneN))+
  geom_bar(colour = "black", position = position_stack(reverse = TRUE), linewidth = 0.3)+
  # geom_text(stat='count', aes(label= ..count..), vjust=-1)+
  # scale_x_discrete(limits = clone_order)+
  theme_classic()+
  # scale_fill_brewer(palette = "GnBu", direction = 1)+
  scale_fill_manual(values = c("#ABDDA4", "#66C2A5", "#3288BD", "#5E4FA2"))+
  labs(y = "Count")+
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle=90))+
  facet_wrap(~day, nrow = 1)
ggsave("Figures/Clonal_expanded_byAnnot_Tfh.pdf", height = 3.5, width = 8)

ggplot(filter(ibsm_rep.expanded@meta.data, !is.na(cloneN) & !alternative_clusters %in% c("Tfh1_CM","Tfh1","Tfh2","Tfh17")), 
       aes(x = alternative_clusters, fill = cloneN))+
  geom_bar(colour = "black", position = position_stack(reverse = TRUE), linewidth = 0.3)+
  # geom_text(stat='count', aes(label= ..count..), vjust=-1)+
  # scale_x_discrete(limits = clone_order)+
  theme_classic()+
  # scale_fill_brewer(palette = "GnBu", direction = 1)+
  scale_fill_manual(values = c("#ABDDA4", "#66C2A5", "#3288BD", "#5E4FA2"))+
  labs(y = "Count")+
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle=90))+
  facet_wrap(~day, nrow = 1)
ggsave("Figures/Clonal_expanded_byAnnot_nonTfh.pdf", height = 3.5, width = 8)
```

## TCR:Cell Proportion 
```{r}
cell.prop <- ibsm_rep@meta.data %>% 
  mutate(TCR = case_when(is.na(CTaa) == TRUE ~ "No",
                         TRUE ~ "Yes"))

cell.prop <- cell.prop %>% 
  group_by(alternative_clusters, TCR) %>% 
  summarise(n = n()) %>% 
  group_by(alternative_clusters) %>% 
  mutate(total = sum(n)) %>% 
  mutate(prop = n/total*100)

ggplot(cell.prop, aes(x = alternative_clusters, y = prop, fill = TCR))+
  geom_col(color = "black")+
  theme_bw()+
  ylab("Proportion")+
  geom_text(aes(label = round(prop, digits = 1)), position = position_stack(vjust = 0.5))+
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))+
  scale_fill_manual(values = c("grey","white"))
ggsave("Figures/TCR_prop.pdf")

celltocsv <- select(ibsm_rep@meta.data, c(5,21,11,4,29))
write.csv2(celltocsv, file = "clean_metadata.csv")

```

## Plot diversity plot

Create a diversity plot for donor_day (per donor and all donor overtime)

NOTE: scRepertoire exportTable output generating WRONG output by rounding off data to whole number. E.g. diversity 0.99 or 0.97 will be rounded off to 1 in exportTable. This is INCORRECT. The plots however, generate the correct diversity index values. 

Use this guide from 10x
https://kb.10xgenomics.com/hc/en-us/articles/13303807883405-How-to-calculate-paired-clonotype-diversity

```{r}
## We need to downsample first
count <- ibsm_rep@meta.data %>% 
  filter(., !is.na(CTaa)) %>% 
  filter(., donor_id != "donor2" | day != "day8") %>% 
  group_by(donor_day) %>% 
  summarise(n = n()) 
min_count <- min(count$n)

set.seed(123)
ibsm_div_day <- ibsm_rep@meta.data %>% 
  filter(., !is.na(CTaa)) %>% 
  group_by(donor_day) %>% 
  slice_sample(., n = 1000) %>%
  group_by(CTaa, day, donor_id) %>%
  summarise(freq=n()) %>%
  group_by(day, donor_id) %>% 
  mutate(sum = sum(freq),
         prop = freq/sum,
         abn = prop^2) %>% 
  summarise(diversity = sum(abn)) %>% 
  mutate(day = factor(day, levels = c("day0","day8","day16","day36"))) %>% 
  filter(., donor_id != "donor2" | day != "day8")
  
ggplot(ibsm_div_day, aes(x = day, y = diversity, color = donor_id))+
  geom_line(aes(group = donor_id))+
  geom_point(size = 2)+
  theme_classic()+
  ylab("Simpson's Diversity Index")+
  scale_color_manual(values = donor_col)
ggsave(filename = "Figures/Diversity_donor_day.pdf", height = 3.5, width = 4)

```

```{r}
# This is if we want to get rid of singletons
saveRDS(ibsm_rep, file = "ibsm_rep_singlets.RDS")

ibsm_rep <- subset(ibsm_rep, subset = clonalFrequency != 1)

saveRDS(ibsm_rep, file = "ibsm_rep_expanded.RDS")
ibsm_rep <- readRDS("ibsm_rep_expanded.RDS")
```


## Create barplot for each donor over time
We want to show clonal expansion for each donor overtime.

```{r}
donors <- mixedsort(unique(ibsm_rep@meta.data$donor_id))

ibsm_bar <- ibsm_rep@meta.data %>% 
  group_by(day, donor_id, donor_day, alternative_clusters) %>% 
  summarise(n = n())

ibsm_bar$day <- factor(ibsm_bar$day, 
                       levels = c("day0","day8","day16","day36"))


cluster_col <- c("Tfh1" = "#9e0142", "Tfh1_CM" = "#f4a582", "Tfh2" = "#5e4fa2", 
                 "Tfh17" = "#66c2a5", "Tfh1.17" = "#e6f598", "Tfreg" = "#74add1", 
                 "IFNI" = "#8c510a", "heatshock" = "#bf812d", "ribo" = "#fee090", 
                 "cluster2" = "#01665e", "cluster3" = "#b2abd2")


for(i in donors){
  print(ggplot(filter(ibsm_bar, donor_id == i), 
               aes(x = day, y = n, 
                   stratum = alternative_clusters,
                   alluvium = alternative_clusters,
                   fill = alternative_clusters))+
          ggtitle(i)+
          theme_classic()+
          theme(panel.grid.major.y = element_line(linetype = "dashed"))+
          geom_stratum()+
          geom_flow()+
          scale_fill_manual(values = cluster_col)
        )
  ggsave(filename = paste0("Figures/Barplot_annot_",i,".pdf"))
}
```


## Create barplot for shared clones

```{r}
ibsm_share <- getCirclize(ibsm_rep,
                 group.by = "alternative_clusters", proportion = T) %>% 
  filter(., from != to) 
  
## Here, shared values between from and to are different, so I had to combine both using rbind and renaming the columns

ibsm_share <- rbind(ibsm_share %>% rename(to = from, from = to),
                    ibsm_share) %>% 
  mutate(value = round(value*100, 1))  

ibsm_share$from <- factor(ibsm_share$from, levels = cluster_orders)

ggplot(filter(ibsm_share, from != to & value != 0), aes(x = from, y = value, fill = to))+
  theme_classic()+
  ylab("Proportion of Clones Sharing")+
  labs(fill = "Cell Type")+
  geom_col(colour = "black")+
  scale_x_discrete(drop = T)+
  geom_text(aes(label = value), size = 3, position = position_stack(vjust = 0.5))+
  scale_fill_manual(values = cluster_col)+
  theme(axis.title.x = element_blank())
ggsave(filename = "Figures/SharedClones.pdf")
```

```{r}
donors <- mixedsort(unique(ibsm_rep@meta.data$donor_id))

for(i in donors){
  per_donor <- getCirclize(
    subset(ibsm_rep, subset = donor_id == i),
    group.by = "alternative_clusters") %>% 
      filter(., from != to) 
 
  per_donor <- rbind(per_donor %>% rename(to = from, from = to),
                    per_donor) %>% 
    mutate(value = round(value*100, 1)) 
  
  per_donor$from <- factor(per_donor$from, levels = cluster_orders)

  print(ggplot(filter(per_donor, from != to & value != 0), aes(x = from, y = value, fill = to))+
  theme_classic()+
  ggtitle(i)+
  ylab("# Clones Sharing")+
  labs(fill = "Cell Type")+
  scale_x_discrete(drop = T)+
  geom_col(colour = "black")+
  geom_text(aes(label = value), size = 3, position = position_stack(vjust = 0.5))+
  scale_fill_manual(values = cluster_col)+
  theme(axis.title.x = element_blank())
  )
  
  ggsave(filename = paste0("Figures/SharedClones_",i,".pdf"))
}
```


## Create Heatmap of Clonal Overlap between donors

NOTE: These results are not bootstrapped. Ilka Wahl paper did bootsrapping 10,000. Need to find out more what's appropriate

```{r}
ibsm_overlap <- clonalOverlap(ibsm_rep, cloneCall = "aa", 
                              method = "jaccard", group.by = "donor_day", exportTable = F)+
    theme(axis.title = element_blank(),
        # axis.text = element_blank(),
        axis.text.x = element_text(angle = 90),
        axis.ticks = element_blank()
        )

meta <- ibsm_rep@meta.data %>% 
  distinct(donor_day, donor_id, day) %>% 
  remove_rownames()
meta$day = factor(meta$day, levels = c('day0','day8','day16','day36'))

donor_labs <- ggplot(meta, aes(donor_day, y=1, fill=donor_id)) + geom_tile() +
  scale_fill_brewer(palette = 'Set1',name="Donor ID") + 
  theme_void() 

day_labs <- ggplot(meta, aes(donor_day, y=1, fill=day)) + geom_tile() +
  scale_fill_brewer(palette = 'Set3',name="Day") + 
  theme_void() 

ibsm_overlap %>% insert_top(., donor_labs, height = .05) %>% 
  insert_top(., day_labs, height = .05)

ggsave(filename = "Figures/ClonalOverlap.pdf")

```






## Create circos plot

Circos plot on TCR clones shared between cell types and day. Here, we want to ask what are the celltype identities clonal pairs and how they are related over time.

### Overall

```{r}
# Create  a new column day_clust for ChordDiagram "sector"
ibsm_rep@meta.data$day_clust <- paste(ibsm_rep@meta.data$day,
                                      ibsm_rep@meta.data$alternative_clusters, sep="_")

# Create circos df using getCirclize function
ibsm_circos <- getCirclize(ibsm_rep, group.by = "day_clust") %>% 
  filter(., value!=0)

# Metadata on naming the group
df_names <- ibsm_rep@meta.data %>% 
  select(alternative_clusters, day, day_clust) %>% 
  distinct(day_clust, .keep_all = TRUE) %>% 
  remove_rownames() %>% 
  arrange(., factor(alternative_clusters))

# We need to match color day_clust variables based on cell type
# Currently done manually, need to find easier way
names <- unique(c(ibsm_circos$from, ibsm_circos$to))

grid.col <- case_when(grepl("_Tfh1$", names) ~ "#9e0142",
                      grepl("_Tfh1_CM$", names) ~ "#f4a582",
                      grepl("Tfh2", names) ~ "#5e4fa2",
                      grepl("Tfh17", names) ~ "#66c2a5",
                      grepl("Tfh1.17", names) ~ "#e6f598",
                      grepl("Tfreg", names) ~ "#74add1",
                      grepl("IFNI", names) ~ "#8c510a",
                      grepl("heatshock", names) ~ "#bf812d",
                      grepl("ribo", names) ~ "#fee090",
                      grepl("_cluster2$", names) ~ "#01665e",
                      grepl("_cluster3$", names) ~ "#b2abd2",
                      TRUE ~ NA)

names(grid.col) <- names

# We want to split the circos based on Day grouping
group = structure(df_names$day, names = df_names$day_clust)
group = factor(group, levels = c("day0", "day8", "day16","day36"))

# Now plot backbone of circos

pdf("Figures/ChordDiagram.pdf")

chordDiagram(ibsm_circos, 
             grid.col = grid.col,
             annotationTrack = "grid",
             preAllocateTracks = list(list(track.height = 0.075),
             #                          # list(track.height = 0.075),
                                      list(track.height = 0.001)),
             annotationTrackHeight = mm_h(5),
             group = group,
             big.gap = 20, small.gap = 1,
             direction.type = c("diffHeight", "arrows"))

# Now manually name the inner sector based on cell type
names <- data.frame(day_clust = get.all.sector.index()) %>% 
  left_join(., df_names, by = "day_clust")
names <- names$alternative_clusters

for(i in seq_along(names)){
  si <- get.all.sector.index()[i]
  nm <- names[i]
  
    xlim = get.cell.meta.data("xlim", sector.index = si, track.index = 2)
    ylim = get.cell.meta.data("ylim", sector.index = si, track.index = 2)
    circos.text(mean(xlim), mean(ylim), nm, sector.index = si, track.index = 2, 
        facing = "outside", niceFacing = TRUE, col = "black", cex = 0.5)
}

# Now plot outer ribbon on days
# highlight.sector(filter(df_names, day == 'day0')$day_clust, track.index = 1, col = viridis(n=4)[1], text = "Day 0", cex = 0.75, text.col = "white", niceFacing = TRUE)
# highlight.sector(filter(df_names, day == 'day8')$day_clust, track.index = 1, col = viridis(n=4)[2], text = "Day 8", cex = 0.75, text.col = "white", niceFacing = TRUE)
# highlight.sector(filter(df_names, day == 'day16')$day_clust, track.index = 1, col = viridis(n=4)[3], text = "Day 16", cex = 0.75, text.col = "white", niceFacing = TRUE)
# highlight.sector(filter(df_names, day == 'day36')$day_clust, track.index = 1, col = viridis(n=4)[4], text = "Day 36", cex = 0.75, text.col = "white", niceFacing = TRUE)

highlight.sector(filter(df_names, day == 'day0')$day_clust, track.index = 1, , border = "black", col = "white", text = "Day 0", cex = 0.75, text.col = "black", niceFacing = TRUE)
highlight.sector(filter(df_names, day == 'day8')$day_clust, track.index = 1, border = "black", col = "white", text = "Day 8", cex = 0.75, text.col = "black", niceFacing = TRUE)
highlight.sector(filter(df_names, day == 'day16')$day_clust, track.index = 1, border = "black", col = "white", text = "Day 16", cex = 0.75, text.col = "black", niceFacing = TRUE)
highlight.sector(filter(df_names, day == 'day36')$day_clust, track.index = 1, border = "black", col = "white", text = "Day 36", cex = 0.75, text.col = "black", niceFacing = TRUE)

circos.clear()

dev.off()

dev.set()
```

### Splitting per donor

```{r}
donors <- mixedsort(unique(ibsm_rep@meta.data$donor_id))

for (i in donors){
  pdf(paste0("Figures/ChordDiagram",i,".pdf"))
  
  # Create circos df using getCirclize function
  ibsm_circos <- getCirclize(subset(ibsm_rep, subset = donor_id == i), 
                             group.by = "day_clust") %>% 
    filter(., value!=0)
  
  # Metadata on naming the group
  df_names <- filter(ibsm_rep@meta.data, donor_id == i) %>% 
    select(alternative_clusters, day, day_clust) %>% 
    distinct(day_clust, .keep_all = TRUE) %>% 
    remove_rownames() %>% 
    arrange(., factor(alternative_clusters))

  
  # We need to match color day_clust variables based on cell type
  # Currently done manually, need to find easier way
  names <- unique(c(ibsm_circos$from, ibsm_circos$to))
  
  grid.col <- case_when(grepl("_Tfh1$", names) ~ "#9e0142",
                        grepl("_Tfh1_CM$", names) ~ "#f4a582",
                        grepl("Tfh2", names) ~ "#5e4fa2",
                        grepl("Tfh17", names) ~ "#66c2a5",
                        grepl("Tfh1.17", names) ~ "#e6f598",
                        grepl("Tfreg", names) ~ "#74add1",
                        grepl("IFNI", names) ~ "#8c510a",
                        grepl("heatshock", names) ~ "#bf812d",
                        grepl("ribo", names) ~ "#fee090",
                        grepl("_cluster2$", names) ~ "#01665e",
                        grepl("_cluster3$", names) ~ "#b2abd2",
                        TRUE ~ NA)
  
  names(grid.col) <- names
  
  # We want to split the circos based on Day grouping
  group = structure(df_names$day, names = df_names$day_clust)
  group = factor(group, levels = mixedsort(unique(group)))
  
  # Now plot backbone of circos
  chordDiagram(ibsm_circos, 
               grid.col = grid.col,
               annotationTrack = "grid",
               preAllocateTracks = list(list(track.height = 0.075),
               #                          # list(track.height = 0.075),
                                        list(track.height = 0.001)),
               annotationTrackHeight = mm_h(5),
               group = group,
               big.gap = 20, small.gap = 1,
               direction.type = c("diffHeight", "arrows"))
  
  title(i)
  
  # Now manually name the inner sector based on cell type
  names <- data.frame(day_clust = get.all.sector.index()) %>% 
    left_join(., df_names, by = "day_clust")
  names <- names$alternative_clusters
  
  for(i in seq_along(names)){
    si <- get.all.sector.index()[i]
    nm <- names[i]
    
      xlim = get.cell.meta.data("xlim", sector.index = si, track.index = 2)
      ylim = get.cell.meta.data("ylim", sector.index = si, track.index = 2)
      circos.text(mean(xlim), mean(ylim), nm, sector.index = si, track.index = 2, 
          facing = "outside", niceFacing = TRUE, col = "black", cex = 0.5)
  }
  
  # Now plot outer ribbon on days
  # highlight.sector(filter(df_names, day == 'day0')$day_clust, track.index = 1, col = viridis(n=4)[1], text = "Day 0", cex = 0.75, text.col = "white", niceFacing = TRUE)
  # highlight.sector(filter(df_names, day == 'day8')$day_clust, track.index = 1, col = viridis(n=4)[2], text = "Day 8", cex = 0.75, text.col = "white", niceFacing = TRUE)
  # highlight.sector(filter(df_names, day == 'day16')$day_clust, track.index = 1, col = viridis(n=4)[3], text = "Day 16", cex = 0.75, text.col = "white", niceFacing = TRUE)
  # highlight.sector(filter(df_names, day == 'day36')$day_clust, track.index = 1, col = viridis(n=4)[4], text = "Day 36", cex = 0.75, text.col = "white", niceFacing = TRUE)
  
  for (j in unique(group)){
    highlight.sector(filter(df_names, day == j)$day_clust, track.index = 1, , border = "black", col = "white", text = j, cex = 0.75, text.col = "black", niceFacing = TRUE)
  }
  
  circos.clear()
  dev.off()
}

dev.set()
```

### Just Day 16

```{r}
# Create  a new column day_clust for ChordDiagram "sector"
ibsm_rep@meta.data$donor_clust <- paste(ibsm_rep@meta.data$donor_id,
                                      ibsm_rep@meta.data$alternative_clusters, sep="_")

# Create circos df using getCirclize function
ibsm_circos <- getCirclize(subset(ibsm_rep, subset = day == "day16"), group.by = "donor_clust") %>% 
  filter(., value!=0)

# Metadata on naming the group
df_names <- ibsm_rep@meta.data %>% 
  select(alternative_clusters, donor_id, donor_clust) %>% 
  distinct(donor_clust, .keep_all = TRUE) %>% 
  remove_rownames() %>% 
  arrange(., factor(alternative_clusters))

# We need to match color day_clust variables based on cell type
# Currently done manually, need to find easier way
names <- unique(c(ibsm_circos$from, ibsm_circos$to))

grid.col <- case_when(grepl("_Tfh1$", names) ~ "#9e0142",
                      grepl("_Tfh1_CM$", names) ~ "#f4a582",
                      grepl("Tfh2", names) ~ "#5e4fa2",
                      grepl("Tfh17", names) ~ "#66c2a5",
                      grepl("Tfh1.17", names) ~ "#e6f598",
                      grepl("Tfreg", names) ~ "#74add1",
                      grepl("IFNI", names) ~ "#8c510a",
                      grepl("heatshock", names) ~ "#bf812d",
                      grepl("ribo", names) ~ "#fee090",
                      grepl("_cluster2$", names) ~ "#01665e",
                      grepl("_cluster3$", names) ~ "#b2abd2",
                      TRUE ~ NA)

names(grid.col) <- names

# We want to split the circos based on Donor grouping
group = structure(df_names$donor_id, names = df_names$donor_clust)
group = factor(group, levels = c("donor0", "donor1", "donor2","donor3"))

# Now plot backbone of circos

pdf("Figures/ChordDiagram_Day16_byDonor.pdf")

chordDiagram(ibsm_circos, 
             grid.col = grid.col,
             annotationTrack = "grid",
             preAllocateTracks = list(list(track.height = 0.075),
             #                          # list(track.height = 0.075),
                                      list(track.height = 0.001)),
             annotationTrackHeight = mm_h(5),
             group = group,
             big.gap = 20, small.gap = 1,
             direction.type = c("diffHeight", "arrows"))

# Now manually name the inner sector based on cell type
names <- data.frame(donor_clust = get.all.sector.index()) %>% 
  left_join(., df_names, by = "donor_clust")
names <- names$alternative_clusters

for(i in seq_along(names)){
  si <- get.all.sector.index()[i]
  nm <- names[i]
  
    xlim = get.cell.meta.data("xlim", sector.index = si, track.index = 2)
    ylim = get.cell.meta.data("ylim", sector.index = si, track.index = 2)
    circos.text(mean(xlim), mean(ylim), nm, sector.index = si, track.index = 2, 
        facing = "outside", niceFacing = TRUE, col = "black", cex = 0.5)
}

# Now plot outer ribbon on days
# highlight.sector(filter(df_names, day == 'day0')$day_clust, track.index = 1, col = viridis(n=4)[1], text = "Day 0", cex = 0.75, text.col = "white", niceFacing = TRUE)
# highlight.sector(filter(df_names, day == 'day8')$day_clust, track.index = 1, col = viridis(n=4)[2], text = "Day 8", cex = 0.75, text.col = "white", niceFacing = TRUE)
# highlight.sector(filter(df_names, day == 'day16')$day_clust, track.index = 1, col = viridis(n=4)[3], text = "Day 16", cex = 0.75, text.col = "white", niceFacing = TRUE)
# highlight.sector(filter(df_names, day == 'day36')$day_clust, track.index = 1, col = viridis(n=4)[4], text = "Day 36", cex = 0.75, text.col = "white", niceFacing = TRUE)

sector.names <- left_join(data.frame(donor_clust = get.all.sector.index()),
                          df_names)

highlight.sector(filter(sector.names, donor_id == 'donor0')$donor_clust, track.index = 1, border = "black", col = "white", text = "Donor 0", cex = 0.75, text.col = "black", niceFacing = TRUE)
highlight.sector(filter(sector.names, donor_id == 'donor1')$donor_clust, track.index = 1, border = "black", col = "white", text = "Donor 1", cex = 0.75, text.col = "black", niceFacing = TRUE)
highlight.sector(filter(sector.names, donor_id == 'donor2')$donor_clust, track.index = 1, border = "black", col = "white", text = "Donor 2", cex = 0.75, text.col = "black", niceFacing = TRUE)
highlight.sector(filter(sector.names, donor_id == 'donor3')$donor_clust, track.index = 1, border = "black", col = "white", text = "Donor 3", cex = 0.75, text.col = "black", niceFacing = TRUE)

circos.clear()

dev.off()

dev.set()
```


## Plot clonal network

Better view of shared clones between cell type within donor, regardless of timepoint

```{r}
g1 = clonalNetwork(ibsm_rep,
              reduction = "umap",
              group.by = "alternative_clusters",
              cloneCall = "aa")+
  ggtitle("All donors")+
  scale_color_manual(values = cluster_col)
g2 = DimPlot(ibsm_rep, reduction = "umap", group.by = "alternative_clusters")+
  scale_color_manual(values = cluster_col)
  
  print(plot_grid(g1, g2))
  ggsave(filename = "Figures/NetworkPlot_AllDonors.pdf", width = 15)

donors <- mixedsort(unique(ibsm_rep@meta.data$donor_id))

cluster <- unique(ibsm_rep@meta.data$alternative_clusters)
cluster_col <- unlist(mapply(brewer.pal,
                             brewer.pal.info[brewer.pal.info$category == 'qual',]$maxcolors, 
                             rownames(brewer.pal.info[brewer.pal.info$category == 'qual',])))

names(cluster_col) <- cluster

  
for (i in donors){
  p1 = clonalNetwork(subset(ibsm_rep, subset = donor_id == i),
              reduction = "umap",
              group.by = "alternative_clusters",
              cloneCall = "aa")+
    ggtitle(i)+
    scale_color_manual(values = cluster_col)
  p2 = DimPlot(ibsm_rep, reduction = "umap", group.by = "alternative_clusters")+
    scale_color_manual(values = cluster_col)
  
  print(plot_grid(p1, p2))
  ggsave(filename = paste0("Figures/NetworkPlot_",i,".pdf"), width = 15)
}
```

## Barplot x = clone
```{r}

bar_clone_a <- ibsm_rep@meta.data %>% 
  subset(., !is.na(CTaa)) %>% 
  group_by(CTaa, alternative_clusters, donor_id) %>% 
  summarise(count = n()) %>% 
  ungroup() %>% 
  group_by(CTaa) %>% 
  mutate(total_n = sum(count)) %>% 
  subset(., total_n > 1)

bar_clone <- ibsm_rep@meta.data %>% 
  subset(., !is.na(CTaa)) %>% 
  group_by(CTaa, alternative_clusters, donor_day, donor_id, day) %>% 
  summarise(count = n()) %>% 
  ungroup() %>% 
  group_by(CTaa) %>% 
  mutate(day = factor(day, levels = c("day0", "day8", "day16", "day36")), 
         total_n = sum(count)) %>% 
  subset(., total_n > 2)

bar_fate <- bar_clone %>% 
  group_by(CTaa, day) %>% 
  mutate(fate = case_when(n()>1 ~ "Different Fate",
                          TRUE ~ "Same Fate")) %>% 
  ungroup() %>% 
  group_by(fate, day, donor_id) %>% 
  summarise(unique.n = n_distinct(CTaa)) %>% 
  ungroup() %>% 
  tidyr::complete(., day, donor_id, fate, fill = list(unique.n = 0))



bar_clone_2 <- ibsm_rep@meta.data %>% 
  subset(., !is.na(CTaa)) %>% 
  group_by(CTaa, alternative_clusters, donor_day, donor_id, day) %>% 
  summarise(count = n()) %>% 
  ungroup() %>% 
  group_by(CTaa) %>% 
  mutate(day = factor(day, levels = c("day0", "day8", "day16", "day36")), 
         total_n = sum(count)) %>% 
  subset(., total_n == 2)

bar_fate_2 <- bar_clone_2 %>% 
  group_by(CTaa, day) %>% 
  mutate(fate = case_when(n()>1 ~ "Different Fate",
                          TRUE ~ "Same Fate"))

cl_order <- bar_clone %>% 
  ungroup() %>% 
  group_by(CTaa) %>% 
  summarise(total = sum(count)) %>% 
  arrange(desc(total))

cl_order <- bar_clone_a %>% 
  ungroup() %>% 
  group_by(CTaa) %>% 
  summarise(total = sum(count)) %>% 
  arrange(desc(total))

ggplot(bar_clone_a, aes(x = CTaa, y = count))+
  scale_x_discrete(limits = cl_order$CTaa)+
  geom_col(aes(fill = alternative_clusters))+
  scale_fill_manual(values = cluster_col)+
  theme_classic()+
  xlab("CTaa")+
  theme(axis.text.x = element_blank())
ggsave(filename = "Figures/ClonalCount_colored_more2.pdf")

ggplot(bar_clone, aes(x = CTaa, y = count))+
  scale_x_discrete(limits = cl_order$CTaa)+
  geom_col(aes(fill = alternative_clusters))+
  scale_fill_manual(values = cluster_col)+
  theme_classic()+
  xlab("CTaa")+
  theme(axis.text.y = element_blank())+
  # coord_flip()+
  facet_wrap(~day, nrow = 1)
ggsave(filename = "Figures/ClonalCount_colored_more2_byDays.pdf")

ggplot(bar_clone_2, aes(x = CTaa, y = count))+
  # scale_x_discrete(limits = cl_order$CTaa)+
  geom_col(aes(fill = alternative_clusters))+
  scale_fill_manual(values = cluster_col)+
  theme_classic()+
  xlab("CTaa")+
  theme(axis.text.x = element_blank())
ggsave(filename = "Figures/ClonalCount_colored_is2.pdf")

ggplot(bar_clone_2, aes(x = CTaa, y = count))+
  # scale_x_discrete(limits = cl_order$CTaa)+
  geom_col(aes(fill = alternative_clusters))+
  scale_fill_manual(values = cluster_col)+
  theme_classic()+
  xlab("CTaa")+
  theme(axis.text.x = element_blank())+
  facet_wrap(~day)
ggsave(filename = "Figures/ClonalCount_colored_is2_byDays.pdf")



p <- filter(bar_fate, day %in% c("day0","day16")) %>% 
  group_by(day) %>% 
  wilcox_test(unique.n ~ fate, paired = F) %>% 
  add_y_position()

ggplot(filter(bar_fate, day %in% c("day0","day16")), aes(x = fate, y = unique.n))+
  stat_summary(fun = sum, geom = "col")+
  theme_classic()+
  xlab(NULL)+
  ylab("Unique Clones (n)")+
  ggtitle("Clones > 2")+
  stat_pvalue_manual(p, label = "p", hide.ns = "p")+
  facet_wrap(~day)
ggsave(filename = "Figures/ClonalCount_byFateDay.pdf")



p <- bar_fate_2 %>% 
  group_by(donor_day, day, donor_id, fate) %>% 
  summarise(count = sum(count)) %>% 
  group_by(fate) %>% 
  wilcox_test(count ~ day, paired = F) %>% 
  add_y_position()

ggplot(bar_fate_2, aes(x = day, y = count))+
  geom_col()+
  theme_classic()+
  xlab(NULL)+
  stat_pvalue_manual(p, label = "p", hide.ns = "p")+
  facet_wrap(~fate)

```

REMINDER: Update same for TfhMAP

## Bar plot same fate or different
Create a barplot showing clone == 2, how many are same fate and different?

```{r}


```



## Plot Gene Usage

Ilka Wahl's paper show what type TRB/TRA genes are being used by CSP-specific clones.
In our case, maybe we can show if there's certain type of genes being used by specific cells, particularly the Tfh subsets.

```{r}
mixedrank = function(x) order(gtools::mixedorder(x))

gu_order <- ibsm_rep@meta.data %>% 
  select(., c("donor_id", "day", "donor_day")) %>% 
  unique() %>% 
  tibble::remove_rownames() %>% 
  arrange(mixedrank(donor_id))

gu_meta <- ibsm_rep 
gu_meta@meta.data <- gu_meta@meta.data %>% 
  mutate(all_annot = paste0(donor_day, "_", alternative_clusters))

meta <- gu_meta@meta.data %>% 
  select(., c("donor_id","donor_day","day","all_annot","alternative_clusters")) %>% 
  distinct() %>% 
  tibble::remove_rownames()

ibsm_guA <- vizGenes(gu_meta,
         chain = "TRA",
         order = "variance",
         plot = "heatmap",
         split.by = "all_annot",
         scale = T,
         exportTable = T
         ) %>% 
  rename(., Gene = "Var1", all_annot = "Var2") %>% 
  left_join(., meta) %>% 
  filter(., day %in% c("day0", "day16"))

ibsm_guA <- ibsm_guA %>% 
  mutate(day_clust = paste0(day,"_",alternative_clusters))

ibsm_guA_diff <- ibsm_guA %>% 
  ungroup() %>% 
  select(., -c("all_annot","donor_day", 4:7)) %>% 
  pivot_wider(., names_from = day, values_from = n) %>% 
  mutate_at(c("day0","day16"), ~replace(., is.na(.), 0)) %>% 
  mutate(diff = day16-day0)

ibsm_guA <- ibsm_guA %>% 
  ungroup() %>% 
  arrange(mixedrank(alternative_clusters))

ggplot(ibsm_guA, aes(x  = Gene, y = alternative_clusters, group = day))+
  # geom_boxplot(outlier.shape = NA)+
  geom_point(aes(color = n, group =day, size = n), position = ggstance::position_dodgev(height = 0.5))+
  theme_minimal()+
  scale_color_viridis()+
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle = 90))


ibsm_guB <- vizGenes(ibsm_rep,
         chain = "TRB",
         order = "variance",
         plot = "heatmap",
         split.by = "donor_day",
         exportTable = T,
         scale = F
         )

gu1 <- vizGenes(subset(ibsm_rep, subset = day == "day0"),
         chain = "TRA",
         order = "variance",
         plot = "heatmap",
         split.by = "day",
         exportTable = F
         )+
  ggtitle("Day 0")+
  # scale_y_discrete(limits = c("day0","day8","day16","day36"))+
  theme(axis.text.y = element_text(size = 10),
        axis.text.x = element_text(size = 8))

gu2 <- vizGenes(subset(ibsm_rep, subset = day == "day16"),
         chain = "TRA",
         order = "variance",
         plot = "heatmap",
         split.by = "day",
         exportTable = F
         )+
  ggtitle("Day 16")+
  # scale_y_discrete(limits = c("day0","day8","day16","day36"))+
  theme(axis.text.y = element_text(size = 10),
        axis.text.x = element_text(size = 8))

gu3 <- vizGenes(subset(ibsm_rep, subset = day == "day0"),
         chain = "TRB",
         order = "variance",
         plot = "heatmap",
         split.by = "day",
         exportTable = F
         )+
  ggtitle("Day 0")+
  # scale_y_discrete(limits = c("day0","day8","day16","day36"))+
  theme(axis.text.y = element_text(size = 10),
        axis.text.x = element_text(size = 8))

gu4 <- vizGenes(subset(ibsm_rep, subset = day == "day16"),
         chain = "TRB",
         order = "variance",
         plot = "heatmap",
         split.by = "day",
         exportTable = F
         )+
  ggtitle("Day 16")+
  # scale_y_discrete(limits = c("day0","day8","day16","day36"))+
  theme(axis.text.y = element_text(size = 10),
        axis.text.x = element_text(size = 8))
print(plot_grid(gu1, gu2, gu3, gu4))


gu5 <- vizGenes(subset(ibsm_rep, subset = day == "day0"),
         chain = "TRA",
         order = "variance",
         plot = "heatmap",
         split.by = "alternative_clusters",
         exportTable = F
         )+
  ggtitle("Day 0")+
  # scale_y_discrete(limits = c("day0","day8","day16","day36"))+
  theme(axis.text.y = element_text(size = 10),
        axis.text.x = element_text(size = 8))


gu6 <- vizGenes(subset(ibsm_rep, subset = day == "day16"),
         chain = "TRA",
         order = "variance",
         plot = "heatmap",
         split.by = "alternative_clusters",
         exportTable = F
         )+
  ggtitle("Day 16")+
  # scale_y_discrete(limits = c("day0","day8","day16","day36"))+
  theme(axis.text.y = element_text(size = 10),
        axis.text.x = element_text(size = 8))

gu7 <- vizGenes(subset(ibsm_rep, subset = day == "day0"),
         chain = "TRB",
         order = "variance",
         plot = "heatmap",
         split.by = "alternative_clusters",
         exportTable = F
         )+
  ggtitle("Day 0")+
  # scale_y_discrete(limits = c("day0","day8","day16","day36"))+
  theme(axis.text.y = element_text(size = 10),
        axis.text.x = element_text(size = 8))


gu8 <- vizGenes(subset(ibsm_rep, subset = day == "day16"),
         chain = "TRB",
         order = "variance",
         plot = "heatmap",
         split.by = "alternative_clusters",
         exportTable = F
         )+
  ggtitle("Day 16")+
  # scale_y_discrete(limits = c("day0","day8","day16","day36"))+
  theme(axis.text.y = element_text(size = 10),
        axis.text.x = element_text(size = 8))
print(plot_grid(gu5, gu6, gu7, gu8))

```

## Plot UMAP of expanded clones

```{r UMAP xpanded}
# ibsm_full <- readRDS("ibsm_full.rds")
# 
# ibsm_tcr <- subset(ibsm_full, subset = )
# 
# cluster_col <- c("Tfh1" = "#9e0142", "Tfh1_CM" = "#f4a582", "Tfh2" = "#5e4fa2", 
#                  "Tfh17" = "#66c2a5", "Tfh1.17" = "#e6f598", "Tfreg" = "#74add1", 
#                  "IFNI" = "#8c510a", "heatshock" = "#bf812d", "ribosomal" = "#fee090", 
#                  "cluster2" = "#01665e", "cluster3" = "#b2abd2")
# 
# xpanded <- list("Tfh1" = WhichCells())
# 
# DimPlot(ibsm_rep)
```


## Clonal overlap Heatmap

```{r Heatmap Overlap}
.colorizer <- function(palette = "inferno", 
                        n= NULL) {
  colors <- hcl.colors(n=n, palette = palette, fixup = TRUE)
  return(colors)
}

df <- getCirclize(subset(ibsm_rep),
                 group.by = "alternative_clusters", proportion = F) %>% 
    pivot_wider(., names_from = from, values_from = value) %>%
    column_to_rownames(., var = "to") %>%
    as.matrix() %>%
    melt() %>%
    mutate(value = ifelse(value==0, NA, value))
  
  mean_value <- mean(na.omit(df[,"value"]))
  
  print(ggplot(df, aes(x = Var1, y = Var2, fill = value))+
      geom_tile()+
      geom_tile(data = df[!is.na(df[,"value"]),], 
                              fill = NA, 
                              lwd= 0.25, 
                              color = "black")+
      geom_text(aes(label = round(value, digits = 3), 
                                  color = ifelse(value <= mean_value,
                                                 "white", "black"),
                    size = 8), 
                              na.rm = TRUE)+
      scale_fill_gradientn(colors = .colorizer("viridis", 7), na.value = "white")+
      scale_color_identity()+
      labs(fill = "Clonal Overlap")+
      theme_classic()+ 
      theme(axis.title = element_blank(),
            axis.text.x = element_text(angle=90))
      )
  ggsave(paste0("Figures/ClonalOverlap_bySubset.pdf"), height = 10, width = 10)
  rm(df)

for(i in unique(ibsm_rep@meta.data$day)){
  df <- getCirclize(subset(ibsm_rep, subset = day == i),
                 group.by = "alternative_clusters", proportion = T) %>% 
    pivot_wider(., names_from = from, values_from = value) %>%
    column_to_rownames(., var = "to") %>%
    as.matrix() %>%
    melt() %>%
    mutate(value = ifelse(value==0, NA, value))
  
  mean_value <- mean(na.omit(df[,"value"]))
  
  print(ggplot(df, aes(x = Var1, y = Var2, fill = value))+
      geom_tile()+
      geom_tile(data = df[!is.na(df[,"value"]),], 
                              fill = NA, 
                              lwd= 0.25, 
                              color = "black")+
      geom_text(aes(label = round(value, digits = 3), 
                                  color = ifelse(value <= mean_value,
                                                 "white", "black")), 
                              na.rm = TRUE)+
      scale_fill_gradientn(colors = .colorizer("viridis", 7), na.value = "white")+
      scale_color_identity()+
      labs(fill = "Clonal Overlap")+
      ggtitle(i)+
      theme_classic()+ 
      theme(axis.title = element_blank(),
            axis.text.x = element_text(angle=90))
      )
  ggsave(paste0("Figures/ClonalOverlap_bySubset_",i,".pdf"))
  rm(df)
}

t <- clonalOverlap(ibsm_rep, cloneCall = "aa", method = "raw", exportTable = T)
  
```


## Clone Fidelity
Currently combined all timepoints, is that reasonable?

```{r}
fidel <- ibsm_rep@meta.data %>% 
  select(CTaa, alternative_clusters) %>% 
  tibble::remove_rownames() %>% 
  group_by(CTaa, alternative_clusters) %>% 
  summarise(n = n()) %>% 
  ungroup() %>% 
  group_by(CTaa) %>% 
  mutate(total = sum(n)) %>% 
  ungroup() %>% 
  mutate(prop = n/total) %>% 
  select(-c(n, total)) %>% 
  pivot_wider(names_from = CTaa, values_from = prop) %>% 
  arrange(., alternative_clusters) %>% 
  column_to_rownames(., var = "alternative_clusters") %>% 
  mutate_all(~replace(., is.na(.), 0)) %>%
  arrange()

count_per_clone <- ibsm_rep@meta.data %>% 
  select(CTaa) %>% 
  tibble::remove_rownames() %>% 
  group_by(CTaa) %>% 
  summarise(n = n()) 

cluster_count <- ibsm_rep@meta.data %>% 
  select(CTaa, alternative_clusters) %>% 
  remove_rownames() %>% 
  group_by(alternative_clusters) %>% 
  summarise(n = n()) %>% 
  mutate(prop = n/sum(n)*100) %>% 
  column_to_rownames(., var = "alternative_clusters")

fidel <- as.matrix(fidel)

library(ComplexHeatmap)

pdf("Figures/Heatmap_fidelity.pdf", width = 20)
Heatmap((fidel),
        name = "Clonal Proportion",
        cluster_columns = T, column_dend_side = "bottom", clustering_method_columns = "ward.D2",
        cluster_rows = F,
        show_column_names = F,
        # left_annotation = rowAnnotation(Prop = anno_barplot(
        #   cluster_count$prop, axis_param = list(direction = "reverse")),
        #                                                   annotation_name_rot = 90),
        top_annotation = HeatmapAnnotation(Count = anno_barplot(
          count_per_clone$n, axis_param = list(at = c(2, 5, 12))), 
          annotation_name_rot = 90),
        # rect_gp = gpar(col = "white", lwd = 0.5),
        width = ncol(fidel)*unit(0.05, "in"),
        height = nrow(fidel)*unit(0.6, "in"),
        col = colorRampPalette(RColorBrewer::brewer.pal(9, "Greens"))(100))  
        # Use continuous scale with 100 shades
dev.off()
dev.set()

```

## Clone Fidelity Separate Tfh

```{r}
fidel <- ibsm_rep@meta.data %>% 
  filter(., alternative_clusters %in% c("Tfh1_CM","Tfh1","Tfh2","Tfh17")) %>% 
  select(CTaa, alternative_clusters) %>% 
  tibble::remove_rownames() %>% 
  group_by(CTaa, alternative_clusters) %>% 
  summarise(n = n()) %>% 
  ungroup() %>% 
  group_by(CTaa) %>% 
  mutate(total = sum(n)) %>% 
  ungroup() %>% 
  mutate(prop = n/total) %>% 
  select(-c(n, total)) %>% 
  pivot_wider(names_from = CTaa, values_from = prop) %>% 
  arrange(., alternative_clusters) %>% 
  column_to_rownames(., var = "alternative_clusters") %>% 
  mutate_all(~replace(., is.na(.), 0)) %>%
  arrange()

count_per_clone <- ibsm_rep@meta.data %>% 
  filter(., alternative_clusters %in% c("Tfh1_CM","Tfh1","Tfh2","Tfh17")) %>% 
  select(CTaa) %>% 
  tibble::remove_rownames() %>% 
  group_by(CTaa) %>% 
  summarise(n = n()) 

cluster_count <- ibsm_rep@meta.data %>% 
  filter(., alternative_clusters %in% c("Tfh1_CM","Tfh1","Tfh2","Tfh17")) %>% 
  select(CTaa, alternative_clusters) %>% 
  remove_rownames() %>% 
  group_by(alternative_clusters) %>% 
  summarise(n = n()) %>% 
  mutate(prop = n/sum(n)*100) %>% 
  column_to_rownames(., var = "alternative_clusters")

fidel <- as.matrix(fidel)

library(ComplexHeatmap)

pdf("Figures/Heatmap_fidelity_Tfh.pdf", width = 15)
Heatmap((fidel),
        name = "Clonal Proportion",
        cluster_columns = T, column_dend_side = "bottom", clustering_method_columns = "ward.D2",
        cluster_rows = F,
        show_column_names = F,
        # left_annotation = rowAnnotation(Prop = anno_barplot(
        #   cluster_count$prop, axis_param = list(direction = "reverse")),
        #                                                   annotation_name_rot = 90),
        top_annotation = HeatmapAnnotation(Count = anno_barplot(
          count_per_clone$n, axis_param = list(at = c(2, 5, 12))), 
          annotation_name_rot = 90),
        # rect_gp = gpar(col = "white", lwd = 0.5),
        width = ncol(fidel)*unit(0.05, "in"),
        height = nrow(fidel)*unit(0.6, "in"),
        col = colorRampPalette(RColorBrewer::brewer.pal(9, "Greens"))(100))  
        # Use continuous scale with 100 shades
dev.off()
dev.set()

```

## Clone Fidelity Separate nonTfh

```{r}
fidel <- ibsm_rep@meta.data %>% 
  filter(., !alternative_clusters %in% c("Tfh1_CM","Tfh1","Tfh2","Tfh17")) %>% 
  select(CTaa, alternative_clusters) %>% 
  tibble::remove_rownames() %>% 
  group_by(CTaa, alternative_clusters) %>% 
  summarise(n = n()) %>% 
  ungroup() %>% 
  group_by(CTaa) %>% 
  mutate(total = sum(n)) %>% 
  ungroup() %>% 
  mutate(prop = n/total) %>% 
  select(-c(n, total)) %>% 
  pivot_wider(names_from = CTaa, values_from = prop) %>% 
  arrange(., alternative_clusters) %>% 
  column_to_rownames(., var = "alternative_clusters") %>% 
  mutate_all(~replace(., is.na(.), 0)) %>%
  arrange()

count_per_clone <- ibsm_rep@meta.data %>% 
  filter(., !alternative_clusters %in% c("Tfh1_CM","Tfh1","Tfh2","Tfh17")) %>% 
  select(CTaa) %>% 
  tibble::remove_rownames() %>% 
  group_by(CTaa) %>% 
  summarise(n = n()) 

cluster_count <- ibsm_rep@meta.data %>% 
  filter(., !alternative_clusters %in% c("Tfh1_CM","Tfh1","Tfh2","Tfh17")) %>% 
  select(CTaa, alternative_clusters) %>% 
  remove_rownames() %>% 
  group_by(alternative_clusters) %>% 
  summarise(n = n()) %>% 
  mutate(prop = n/sum(n)*100) %>% 
  column_to_rownames(., var = "alternative_clusters")

fidel <- as.matrix(fidel)

library(ComplexHeatmap)

pdf("Figures/Heatmap_fidelity_nonTfh.pdf", width = 15)
Heatmap((fidel),
        name = "Clonal Proportion",
        cluster_columns = T, column_dend_side = "bottom", clustering_method_columns = "ward.D2",
        cluster_rows = F,
        show_column_names = F,
        # left_annotation = rowAnnotation(Prop = anno_barplot(
        #   cluster_count$prop, axis_param = list(direction = "reverse")),
        #                                                   annotation_name_rot = 90),
        top_annotation = HeatmapAnnotation(Count = anno_barplot(
          count_per_clone$n, axis_param = list(at = c(2, 5, 12))), 
          annotation_name_rot = 90),
        # rect_gp = gpar(col = "white", lwd = 0.5),
        width = ncol(fidel)*unit(0.05, "in"),
        height = nrow(fidel)*unit(0.6, "in"),
        col = colorRampPalette(RColorBrewer::brewer.pal(9, "Greens"))(100))  
        # Use continuous scale with 100 shades
dev.off()
dev.set()

```



### By day
```{r}
library(ComplexHeatmap)

for (i in unique(ibsm_rep@meta.data$day)){
  fidel <- ibsm_rep@meta.data %>% 
    filter(., day == i) %>% 
    select(CTaa, alternative_clusters) %>% 
    tibble::remove_rownames() %>% 
    group_by(CTaa, alternative_clusters) %>% 
    summarise(n = n()) %>% 
    ungroup() %>% 
    group_by(CTaa) %>% 
    mutate(total = sum(n)) %>% 
    ungroup() %>% 
    mutate(prop = n/total) %>% 
    select(-c(n, total)) %>% 
    pivot_wider(names_from = CTaa, values_from = prop) %>% 
    arrange(., alternative_clusters) %>% 
    column_to_rownames(., var = "alternative_clusters") %>% 
    mutate_all(~replace(., is.na(.), 0)) %>%
    arrange()

  count_per_clone <- ibsm_rep@meta.data %>% 
    filter(., day == i) %>% 
    select(CTaa) %>% 
    tibble::remove_rownames() %>% 
    group_by(CTaa) %>% 
    summarise(n = n()) 
  max_count <- max(count_per_clone$n)

  cluster_count <- ibsm_rep@meta.data %>% 
    filter(., day == i) %>% 
    select(CTaa, alternative_clusters) %>% 
    remove_rownames() %>% 
    group_by(alternative_clusters) %>% 
    summarise(n = n()) %>% 
    mutate(prop = n/sum(n)*100) %>% 
    column_to_rownames(., var = "alternative_clusters")

  fidel <- as.matrix(fidel)

  pdf(paste0("Figures/Heatmap_fidel_",i,".pdf"), width = 20, height = 10)
  print(Heatmap((fidel),
          column_title = paste0(i),
          name = "Clonal Proportion",
          cluster_columns = T, column_dend_side = "bottom", clustering_method_columns = "ward.D2",
          cluster_rows = F,
          show_column_names = F,
          # left_annotation = rowAnnotation(Prop = anno_barplot(
          #   cluster_count$prop, axis_param = list(direction = "reverse")),
          #                                                   annotation_name_rot = 90),
          top_annotation = HeatmapAnnotation(Count = anno_barplot(
            count_per_clone$n, axis_param = list(at = c(2, 5, max_count))), 
            annotation_name_rot = 90),
          # rect_gp = gpar(col = "white", lwd = 0.5),
          width = ncol(fidel)*unit(0.05, "in"),
          height = nrow(fidel)*unit(0.6, "in"),
          col = colorRampPalette(RColorBrewer::brewer.pal(9, "Greens"))(100))
  )
          # Use continuous scale with 100 shades
  dev.off()
  dev.set()
}


```



## Clonal overlap heatmap

```{r}
fidel <- ibsm_rep@meta.data %>% 
  select(CTaa, alternative_clusters) %>% 
  tibble::remove_rownames() %>% 
  group_by(CTaa, alternative_clusters) %>% 
  summarise(n = n()) %>% 
  ungroup() %>% 
  group_by(CTaa) %>% 
  mutate(total = sum(n)) %>% 
  ungroup() %>% 
  mutate(prop = n/total) %>% 
  select(-c(prop, total)) %>% 
  pivot_wider(names_from = alternative_clusters, values_from = n)
  # arrange(., alternative_clusters) %>% 
  # column_to_rownames(., var = "alternative_clusters") %>% 
  # mutate_all(~replace(., is.na(.), 0)) %>%
  # arrange()

# subset_cols <- c("Tfh2", "Tfh1_CM", "Tfh1", "ribo", "cluster2", "heatshock", "cluster3", "IFNI", "Tfh17", "Tfreg")
subset_cols <- names(fidel)[-c(1)]

# Step 1: Create a binary matrix where 1 indicates presence of a clone in a subset, 0 otherwise
df_binary <- fidel
df_binary[subset_cols] <- lapply(fidel[subset_cols], function(x) ifelse(is.na(x), 0, 1))

# Step 2: Initialize a matrix to store the final sharing proportions
sharing_matrix <- matrix(0, nrow = length(subset_cols), ncol = length(subset_cols))
rownames(sharing_matrix) <- colnames(sharing_matrix) <- subset_cols

# Step 3: Calculate column-wise proportions
for(j in 1:length(subset_cols)) {
  
  # Step 4: Calculate the total number of clones in subset j (column-wise total), including both exclusive and shared clones
  total_clones_j <- sum(df_binary[[subset_cols[j]]] > 0)
  
  # Handle cases where a subset has no clones at all
  if (total_clones_j == 0) {
    next
  }
  
  for(i in 1:length(subset_cols)) {
    
    if (i == j) {
      # Step 5: Diagonal entries - Proportion of exclusive clones in subset j
      exclusive_clones_j <- sum(df_binary[[subset_cols[j]]] & rowSums(df_binary[, subset_cols[-j]]) == 0)
      sharing_matrix[i, j] <- exclusive_clones_j / total_clones_j
      
    } else {
      # Step 6: Off-diagonal entries - Proportion of shared clones between subset i and subset j, relative to subset j's total
      shared_clones_i_j <- sum(df_binary[[subset_cols[i]]] & df_binary[[subset_cols[j]]])
      sharing_matrix[i, j] <- shared_clones_i_j / total_clones_j
    }
  }
}

# Final sharing_matrix with column-wise proportions
sharing_matrix

t <- sharing_matrix %>% 
  as.matrix() %>% 
  melt() %>%
  mutate(., Var1 = factor(Var1, c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17", "Tfh1.17", "Tfreg", "IFNI", "heatshock", "ribo", "cluster2", "cluster3")),
         Var2 = factor(Var2, c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17", "Tfh1.17", "Tfreg", "IFNI", "heatshock", "ribo", "cluster2", "cluster3")))
  # mutate(value = ifelse(value==0, NA, value))
  
mean_value <- mean(na.omit(t[,"value"]))

print(ggplot(t, aes(x = Var1, y = Var2, fill = value))+
      geom_tile()+
      geom_tile(data = t[!is.na(t[,"value"]),], 
                              fill = NA, 
                              lwd= 0.25, 
                              color = "black")+
      geom_text(aes(label = round(value, digits = 3), 
                                  color = ifelse(value <= mean_value,
                                                 "white", "black"),
                    size = 8), 
                              na.rm = TRUE)+
      scale_fill_gradientn(colors = .colorizer("viridis", 7), na.value = "white")+
      scale_color_identity()+
      labs(fill = "Clonal Overlap")+
      theme_classic()+ 
      theme(axis.title = element_blank(),
            axis.text.x = element_text(angle=90))
      )
ggsave(paste0("Figures/Clone_proportion_overlap.pdf"), height = 8, width = 8)

```


By Day
```{r}
for (a in unique(ibsm_rep@meta.data$day)){
  fidel <- ibsm_rep@meta.data %>% 
    filter(., day == a) %>% 
    select(CTaa, alternative_clusters) %>% 
    tibble::remove_rownames() %>% 
    group_by(CTaa, alternative_clusters) %>% 
    summarise(n = n()) %>% 
    ungroup() %>% 
    group_by(CTaa) %>% 
    mutate(total = sum(n)) %>% 
    ungroup() %>% 
    mutate(prop = n/total) %>% 
    select(-c(prop, total)) %>% 
    pivot_wider(names_from = alternative_clusters, values_from = n)
    # arrange(., alternative_clusters) %>% 
    # column_to_rownames(., var = "alternative_clusters") %>% 
    # mutate_all(~replace(., is.na(.), 0)) %>%
    # arrange()


  # Assuming your dataframe is named df
  # subset_cols <- c("Tfh2", "Tfh1_CM", "Tfh1", "ribo", "cluster2", "heatshock", "cluster3", "IFNI", "Tfh17", "Tfreg")
  subset_cols <- names(fidel)[-c(1)]

  # Step 1: Create a binary matrix where 1 indicates presence of a clone in a subset, 0 otherwise
  df_binary <- fidel
  df_binary[subset_cols] <- lapply(fidel[subset_cols], function(x) ifelse(is.na(x), 0, 1))
  
  # Step 2: Initialize a matrix to store the final sharing proportions
  sharing_matrix <- matrix(0, nrow = length(subset_cols), ncol = length(subset_cols))
  rownames(sharing_matrix) <- colnames(sharing_matrix) <- subset_cols
  
  # Step 3: Calculate proportions for exclusive and shared clones relative to the total number of clones in each subset
  for(i in 1:length(subset_cols)) {
    
    # Step 4: Calculate the total number of clones in subset i (including exclusive and shared)
    total_clones_i <- sum(df_binary[[subset_cols[i]]] > 0)
    
    for(j in 1:length(subset_cols)) {
      
      if (i == j) {
        # Step 5: Diagonal entries - Proportion of exclusive clones in subset i
        exclusive_clones_i <- sum(df_binary[[subset_cols[i]]] & rowSums(df_binary[, subset_cols[-i]]) == 0)
        sharing_matrix[i, i] <- exclusive_clones_i
        
      } else {
        # Step 6: Off-diagonal entries - Proportion of shared clones between subset i and j, relative to subset i's total
        shared_clones_i_j <- sum(df_binary[[subset_cols[i]]] & df_binary[[subset_cols[j]]])
        sharing_matrix[i, j] <- shared_clones_i_j
      }
    }
  }
  
  # Final sharing_matrix with proportions relative to each subset's own total clone count
  sharing_matrix
  
  t <- sharing_matrix %>% 
    as.matrix() %>% 
    melt() %>%
    mutate(., Var1 = factor(Var1, c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17", "Tfh1.17", "Tfreg", "IFNI", "heatshock", "ribo", "cluster2", "cluster3")),
           Var2 = factor(Var2, c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17", "Tfh1.17", "Tfreg", "IFNI", "heatshock", "ribo", "cluster2", "cluster3")))
    # mutate(value = ifelse(value==0, NA, value))
    
  mean_value <- mean(na.omit(t[,"value"]))
  
  print(ggplot(t, aes(x = Var1, y = Var2, fill = value))+
        geom_tile()+
        geom_tile(data = t[!is.na(t[,"value"]),], 
                                fill = NA, 
                                lwd= 0.25, 
                                color = "black")+
        geom_text(aes(label = round(value, digits = 2), 
                                    color = ifelse(value <= mean_value,
                                                   "white", "black"),
                      size = 8), 
                                na.rm = TRUE)+
        scale_fill_gradientn(colors = .colorizer("viridis", 7), na.value = "white")+
        scale_color_identity()+
        labs(fill = "Clonal Overlap")+
        theme_classic()+ 
        theme(axis.title = element_blank(),
              axis.text.x = element_text(angle=90))
        )
  ggsave(paste0("Figures/",a,"proportion_overlap.pdf"), height = 8, width = 8)
}

```




## Creating network plot
```{r}
ibsm.csv <- rio::import("/Users/damian.oyong/Library/CloudStorage/OneDrive-BurnetInstitute/Burnet/Projects/PROJECT - Tfh IBSM40/TfhIBSM_Day36_Abfulldf_18Feb25.csv") %>% 
  select(-c(1))
```

Correlation network

AIM Tfh vs Ab Score
```{r}
ibsm_cor <- ibsm.csv %>% 
  select(., matches("Donor|Tfh|Ab_score")) %>% 
  column_to_rownames(., var = "Donor") %>% 
  rstatix::cor_mat(., method = "spearman")

ibsm.corp <- cor_get_pval(ibsm_cor) %>% 
  column_to_rownames(., var = "rowname")

ibsm_cor <- ibsm_cor %>% 
  column_to_rownames(., var = "rowname")


ibsm_cor[ibsm.corp > 0.05] <- 0
# ibsm_cor[ibsm_cor < 0.5] <- 0

library(network)
ibsm.net <- network::network(ibsm_cor %>% as.matrix(), 
                             ignore.eval = F, names.eval = "Spearman")

corr.meta <- data.frame(Subset = colnames(comb_all)[3:ncol(comb_all)]) %>% 
  mutate(Panel = case_when(Subset %in% colnames(t_panel) ~ "Tcell",
                           Subset %in% colnames(b_panel) ~ "Bcell",
                           Subset %in% colnames(gd_panel) ~ "gD",
                           Subset %in% colnames(nk_panel) ~ "NK",
                           Subset %in% colnames(inn_panel) ~ "Innate",
                           Subset %in% colnames(metadata) ~ "Clinical",
                           TRUE ~ NA))
  
corr.net %v% "Panel" <- corr.meta$Panel

GGally::ggnet2(ibsm.net,
               mode = "fruchtermanreingold",
               layout.par = list(cell.jitter = 0.75),
               # color = "Panel",
               palette = "Set2",
               node.alpha = 0.7,
               edge.color = c("color", "red"),
               edge.alpha = 0.5,
               edge.size = "Spearman",
               # edge.lty = "lty"
               )+
  geom_point(aes(color = color), size = 3)


t <- ibsm_cor
t2 <- cor(t, method = "spearman")
t1 <- qgraph::qgraph(cor(t, method="spearman"), minimum = 0.25, cut = 0.4, vsize = 1.5, layout = "spring",
                     palette = "colorblind",
                     posCol = "red", negCol = "blue")


# Load necessary libraries
library(qgraph)
library(Hmisc)  # For rcorr to get correlations and p-values

# Example dataset
data <- ibsm_cor

# Step 1: Calculate correlation matrix and p-values
res <- rcorr(as.matrix(data), type = "spearman")

# Correlation matrix
cor_matrix <- res$r

# P-value matrix
p_matrix <- res$P

# Step 2: Define a significance level (e.g., alpha = 0.05)
alpha <- 0.05

# Step 3: Set correlations with p-values > alpha to 0
cor_matrix[p_matrix > alpha] <- 0

groups <- list(
  "Cellular Response" = c("Tfh1CM_Tfhp", "Tfh1EM_Tfhp", "Tfh2_Tfhp", "Tfh17_Tfhp"),
  "Antibody Response" = "Ab_score"
)

# Define group colors (optional but recommended for clarity)
group_colors <- c("Cellular Response" = "skyblue", 
                  "Antibody Response" = "lightcoral")

color_vector <- ifelse(colnames(cor_matrix) %in% groups$`Cellular Response`, 
                       "skyblue", "lightcoral")

# Plot the network with group colors
qgraph(input = cor_matrix,
       layout = "spring",
       # groups = groups,
       minimum = 0.2,
       cut = 0,
       details = T,
       threshold = 0,
       palette = "colorblind",
       theme = "colorblind",
       # graph = "glasso", threshold = "none",
       # sampleSize = nrow(as.matrix(data)),
       borders = T, border.color = "black", border.width = 0.5, shape = "circle",
       
       # negDashed = T,
       posCol = "lightcoral", negCol = "skyblue",
       label.cex = 2,
       curveAll = T, curDefault = 0.5,
       legend.cex = 0.3, legend.mode = "style2",
       font = 2,
       labels = colnames(cor_matrix)
       )



```

```{r}
ibsm_cor <- ibsm.csv %>% 
  select(., -c("Cohort","Day","CMV")) %>% 
  column_to_rownames(., var = "Donor")

# Example dataset
data <- ibsm_cor

# Step 1: Calculate correlation matrix and p-values
res <- rcorr(as.matrix(data), type = "spearman")

# Correlation matrix
cor_matrix <- res$r

# P-value matrix
p_matrix <- res$P

# Step 2: Define a significance level (e.g., alpha = 0.05)
alpha <- 0.05

# Step 3: Set correlations with p-values > alpha to 0
cor_matrix[p_matrix > alpha] <- 0

groups <- list(
  "Cellular Response" = c("Tfh1CM_Tfhp", "Tfh1EM_Tfhp", "Tfh2_Tfhp", "Tfh17_Tfhp"),
  "Antibody Response" = rownames(cor_matrix)[c(1:20,25)]
)

# Define group colors (optional but recommended for clarity)
group_colors <- c("Cellular Response" = "skyblue", 
                  "Antibody Response" = "lightcoral")

color_vector <- ifelse(colnames(cor_matrix) %in% groups$`Cellular Response`, 
                       "skyblue", "lightcoral")

# Plot the network with group colors
qgraph(input = cor_matrix, overlay = TRUE,
       layout = "spring",
       groups = groups,
       minimum = 0.2,
       cut = 0,
       details = T,
       threshold = 0,
       palette = "colorblind",
       theme = "colorblind",
       # graph = "glasso", threshold = "none",
       # sampleSize = nrow(as.matrix(data)),
       borders = T, border.color = "black", border.width = 0.5, shape = "circle",
       
       # negDashed = T,
       posCol = "lightcoral", negCol = "skyblue",
       label.cex = 2,
       curveAll = T, curDefault = 0.5,
       legend.cex = 0.3, legend.mode = "style2",
       font = 2
       # labels = colnames(cor_matrix)
       )


data(big5)
data(big5groups)

# Correlations:
Q <- qgraph(cor(big5), minimum = 0.25, cut = 0.4, vsize = 1.5, groups = big5groups, 
    legend = TRUE, borders = FALSE)
title("Big 5 correlations", line = 2.5)

```

