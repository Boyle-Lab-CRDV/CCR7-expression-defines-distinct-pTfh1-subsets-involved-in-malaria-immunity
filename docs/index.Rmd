---
title: "CCR7 expression defines distinct pTfh1 subsets involved in malaria immunity"
author: "Megan Soon and Damian Oyong"
date: "2025-03-03"
output: html_document
        toc: TRUE
---

```{r setup0, include=TRUE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r setup, include=FALSE}
suppressPackageStartupMessages(library(plyr))
suppressPackageStartupMessages(library(tidyr))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(Seurat))  
suppressPackageStartupMessages(library(patchwork))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(sctransform))
suppressPackageStartupMessages(library(BiocManager))
suppressPackageStartupMessages(library(limma))
suppressPackageStartupMessages(library(scCustomize))
suppressPackageStartupMessages(library(qs))
suppressPackageStartupMessages(library(viridis))
suppressPackageStartupMessages(library(Seurat))
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggpubr))
suppressPackageStartupMessages(library(scRepertoire))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(gtools))
suppressPackageStartupMessages(library(ggraph))
suppressPackageStartupMessages(library(tibble))
suppressPackageStartupMessages(library(circlize))
suppressPackageStartupMessages(library(ggalluvial))
suppressPackageStartupMessages(library(RColorBrewer))
suppressPackageStartupMessages(library(rstackdeque))
suppressPackageStartupMessages(library(ComplexHeatmap))
suppressPackageStartupMessages(library(sctransform))
suppressPackageStartupMessages(library(harmony))
suppressPackageStartupMessages(library(openxlsx))
suppressPackageStartupMessages(library(HGNChelper))
suppressPackageStartupMessages(library(pheatmap))
suppressPackageStartupMessages(library(forcats))
suppressPackageStartupMessages(library(ggthemes))
suppressPackageStartupMessages(library(ggrepel))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(ggfortify))
suppressPackageStartupMessages(library(ggpubr))
suppressPackageStartupMessages(library(gplots))
suppressPackageStartupMessages(library(limma))
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(rstatix))
suppressPackageStartupMessages(library(eulerr))
```

## Figure 1

Reading input Input can be found in zenodo <https://zenodo.org/records/14847353> Raw data have been deposited in the NCBI data base under accession number GSE272939 <https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE272939> and accession number GSE253661 <https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE253661>

```{r reading input and cleaning up low quality clusters, include=FALSE,echo=TRUE,warning=FALSE, fig.width=8, fig.height=5}
Tfh.Map <- readRDS("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_GEX_4.4/input/MapTfh_TRremoved_integrated_reclustered_210823.rds")

#Removing cluster with high mitochondrial content
Tfh.Map <- subset(Tfh.Map, subset = integratedcluster %in% c("cluster2", "cluster3", "heatshock","IFNI","ribosomal","Tfh1","Tfh1_CM","Tfh1.17","Tfh17","Tfh2","Tfreg"))

Tfh.Map@meta.data$integratedcluster <- factor(Tfh.Map@meta.data$integratedcluster, levels = c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17","Tfh1.17", "Tfreg", "IFNI", "heatshock", "ribosomal", "cluster2", "cluster3"))
```

#### Figure 1 B \| UMAP of data following integration by donor, with 11 transcriptional subsets indicated

```{r Figure1B_UMPA UMAP of data following integration by donor, with 11 transcriptional subsets indicated, include=TRUE, warning=FALSE, out.width="70%", fig.align='center'}
DimPlot(Tfh.Map, label = TRUE, pt.size = 2, group.by = "integratedcluster", 
        cols = c("#9e0142", "#f4a582", "#5e4fa2", "#66c2a5", "#e6f598", 
                 "#74add1", "#8c510a", "#bf812d", "#fee090", "#01665e", "#b2abd2")) 

```

#### Figure 1 C \| UMAP of data depicting cell sorted identity

```{r Figure1C_UMAP of data depicting cell sorted identity,echo=TRUE,warning=FALSE, fig.width=8, fig.height=5, out.width="70%", fig.align='center'}
DefaultAssay(Tfh.Map)

DimPlot(Tfh.Map, label = FALSE, pt.size = 2, group.by = "celltype", 
        cols = c("#c2a5cf","#d53e4f", "#1a9850", "#3288bd" ))
```

```{r Finding clusters markers, include=TRUE, warning=FALSE}
DefaultAssay(Tfh.Map) <- "RNA"
Tfh.Map <- NormalizeData(Tfh.Map)

cluster.2m <- FindMarkers(Tfh.Map, ident.1 = "cluster2", group.by = "integratedcluster", min.pct = 0.1, verbose = FALSE, only.pos = FALSE) 
cluster.3m <- FindMarkers(Tfh.Map, ident.1 = "cluster3", group.by = "integratedcluster", min.pct = 0.1, verbose = FALSE, only.pos = FALSE) 
heatshock.m <- FindMarkers(Tfh.Map, ident.1 = "heatshock", group.by = "integratedcluster", min.pct = 0.1, verbose = FALSE, only.pos = FALSE) 
IFNI.m <- FindMarkers(Tfh.Map, ident.1 = "IFNI", group.by = "integratedcluster", min.pct = 0.1, verbose = FALSE, only.pos = FALSE) 
ribosomal.m <- FindMarkers(Tfh.Map, ident.1 = "ribosomal", group.by = "integratedcluster", min.pct = 0.1, verbose = FALSE, only.pos = FALSE) 
Tfh1.m <- FindMarkers(Tfh.Map, ident.1 = "Tfh1", group.by = "integratedcluster", min.pct = 0.1, verbose = FALSE, only.pos = FALSE) 
Tfh1_CM.m <- FindMarkers(Tfh.Map, ident.1 = "Tfh1_CM", group.by = "integratedcluster", min.pct = 0.1, verbose = FALSE, only.pos = FALSE) 
Tfh1.17.m <- FindMarkers(Tfh.Map, ident.1 = "Tfh1.17", group.by = "integratedcluster", min.pct = 0.1, verbose = FALSE, only.pos = FALSE) 
Tfh17.m <- FindMarkers(Tfh.Map, ident.1 = "Tfh17", group.by = "integratedcluster", min.pct = 0.1, verbose = FALSE, only.pos = FALSE) 
Tfh2.m <- FindMarkers(Tfh.Map, ident.1 = "Tfh2", group.by = "integratedcluster", min.pct = 0.1, verbose = FALSE, only.pos = FALSE) 
Tfreg.m <- FindMarkers(Tfh.Map, ident.1 = "Tfreg", group.by = "integratedcluster", min.pct = 0.1, verbose = FALSE, only.pos = FALSE) 

DefaultAssay(Tfh.Map)

##  add "neg" and "pos" to gene lists..
### can we also know how many are upregulated vs downregulated??
cluster.2m$dir_sig[cluster.2m$p_val_adj<0.01 & cluster.2m$avg_log2FC>0] <-"up"
cluster.2m$dir_sig[cluster.2m$p_val_adj<0.01 & cluster.2m$avg_log2FC<0] <-"down"

cluster.3m$dir_sig[cluster.3m$p_val_adj<0.01 & cluster.3m$avg_log2FC>0] <-"up"
cluster.3m$dir_sig[cluster.3m$p_val_adj<0.01 & cluster.3m$avg_log2FC<0] <-"down"

heatshock.m$dir_sig[heatshock.m$p_val_adj<0.01 & heatshock.m$avg_log2FC>0] <-"up"
heatshock.m$dir_sig[heatshock.m$p_val_adj<0.01 & heatshock.m$avg_log2FC<0] <-"down"

IFNI.m$dir_sig[IFNI.m$p_val_adj<0.01 & IFNI.m$avg_log2FC>0] <-"up"
IFNI.m$dir_sig[IFNI.m$p_val_adj<0.01 & IFNI.m$avg_log2FC<0] <-"down"

ribosomal.m$dir_sig[ribosomal.m$p_val_adj<0.01 & ribosomal.m$avg_log2FC>0] <-"up"
ribosomal.m$dir_sig[ribosomal.m$p_val_adj<0.01 & ribosomal.m$avg_log2FC<0] <-"down"

Tfh1.m$dir_sig[Tfh1.m$p_val_adj<0.01 & Tfh1.m$avg_log2FC>0] <-"up"
Tfh1.m$dir_sig[Tfh1.m$p_val_adj<0.01 & Tfh1.m$avg_log2FC<0] <-"down"

Tfh1_CM.m$dir_sig[Tfh1_CM.m$p_val_adj<0.01 & Tfh1_CM.m$avg_log2FC>0] <-"up"
Tfh1_CM.m$dir_sig[Tfh1_CM.m$p_val_adj<0.01 & Tfh1_CM.m$avg_log2FC<0] <-"down"

Tfh1.17.m$dir_sig[Tfh1.17.m$p_val_adj<0.01 & Tfh1.17.m$avg_log2FC>0] <-"up"
Tfh1.17.m$dir_sig[Tfh1.17.m$p_val_adj<0.01 & Tfh1.17.m$avg_log2FC<0] <-"down"

Tfh17.m$dir_sig[Tfh17.m$p_val_adj<0.01 & Tfh17.m$avg_log2FC>0] <-"up"
Tfh17.m$dir_sig[Tfh17.m$p_val_adj<0.01 & Tfh17.m$avg_log2FC<0] <-"down"

Tfh2.m$dir_sig[Tfh2.m$p_val_adj<0.01 & Tfh2.m$avg_log2FC>0] <-"up"
Tfh2.m$dir_sig[Tfh2.m$p_val_adj<0.01 & Tfh2.m$avg_log2FC<0] <-"down"

Tfreg.m$dir_sig[Tfreg.m$p_val_adj<0.01 & Tfreg.m$avg_log2FC>0] <-"up"
Tfreg.m$dir_sig[Tfreg.m$p_val_adj<0.01 & Tfreg.m$avg_log2FC<0] <-"down"

#### Get Tfh1 vs Tfh1.CM genes ####
Tfh1vsCM<- FindMarkers(Tfh.Map, ident.1 = "Tfh1", ident.2 = "Tfh1_CM", group.by = "integratedcluster", min.pct = 0.1, verbose = FALSE, only.pos = FALSE) 
```

#### Figure 1 D \| Relative gene expression of genes used to annotate transcriptional clusters.

```{r Figure1D_Relative gene expression of genes used to annotate transcriptional clusters,echo=TRUE,warning=FALSE, fig.width=6, fig.height=8, , out.width="70%", fig.align='center'}

dotplot.genes <- c("KLF6", "CD44", "ANXA1",
                   "ZFP36", "JUND", "FTH1", "NR4A2",
                   "HSPB1", "HSPA6",
                   "ISG20", "IFI44", "ISG15",
                   "CTLA4", "FOXP3",
                   "TGFB1", "BHLHE40", "CCR6",
                   "TCF7", "MAF", "TOX2",
                   "TIGIT", "SH2D1A", "CCR7", "CXCR3",
                   "NKG7", "CST7", "CCL5", "GZMK")

DotPlot_scCustom(Tfh.Map, features = dotplot.genes, colors_use = viridis_magma_dark_high, 
                 group.by = "integratedcluster", flip_axes = T,
                 x_lab_rotate = TRUE)

```

#### Figure 1 E \| Subset of genes differentially expressed between Tfh1_Cyto and Tfh1_CCR7 annotated transcriptional clusters

```{r Figure1E_Subset of genes differentially expressed between Tfh1_Cyto and Tfh1_CCR7 annotated transcriptional clusters, include=TRUE, echo=TRUE,warning=FALSE, fig.width=2, fig.height=6, out.width="50%", fig.align='center'}

# subset
Tfh1CM.sub <- subset(Tfh.Map, subset = integratedcluster %in% c("Tfh1", "Tfh1_CM"))

DefaultAssay(Tfh1CM.sub)

Tfh1.CM_colors <- c("#9e0142", "#f4a582")

Tfh1.CM_list <- c("CCL5", "NKG7", "GZMM", "CCR7",  "SELL")

Stacked_VlnPlot(seurat_object = Tfh1CM.sub, features = Tfh1.CM_list, x_lab_rotate = TRUE,
                colors_use = Tfh1.CM_colors, group.by = "integratedcluster")

```

#### Figure 1 F \| Relationship between cell sorted identity and transcriptional cluster identity in the data set

```{r Figure1F_Relationship between cell sorted identity and transcriptional cluster identity in the data set,echo=TRUE,warning=FALSE, fig.width=4, fig.height=6, out.width="50%", fig.align='center'}

Tfh.Map@meta.data$celltype = factor(Tfh.Map@meta.data$celltype, levels=c("Tfh1","Tfh2", "Tfh17", "PD1n" ))

ggplot(data = as.data.frame(Tfh.Map@meta.data), aes(x = celltype, fill = integratedcluster)) +
  geom_bar(position = "fill") +
  scale_fill_manual(values = c("#9e0142", "#f4a582", "#5e4fa2", "#66c2a5", "#e6f598", 
                               "#74add1", "#8c510a", "#bf812d", "#fee090", "#01665e", "#b2abd2"))
```

##### TCR analysis Figure 1

Input data, can be downloaded from the NCBI data base under accession number GSE272939 <https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE272939>

```{r Reading TCR data for Figure 1, include=TRUE, echo=TRUE,warning=FALSE, eval=FALSE}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # This only works if you are using RStudio

file.names <- list.files(pattern = 'filtered_contig_annotations.csv', recursive = TRUE)
names <- list.files(path='VDJ_Mode')

file_seq <- 1:length(file.names)

if(any(grepl("*.csv", file.names))==TRUE){
  tfh_tcr <- file.names %>% 
    lapply(., function(i){
      fread(input = i)
    }) %>%
    setNames(names)
}


tfh_tcr <- combineTCR(tfh_tcr,
                      samples = names,
                      removeNA = TRUE,
                      removeMulti = TRUE,
                      filterMulti = TRUE)


## Now we need to edit the barcode, delete everything before "v3_"

tfh_tcr <- tfh_tcr %>% 
  purrr::map(~.x %>% mutate(barcode = gsub(".*v3_","",barcode)))


tfh_tcr <- tfh_tcr[c("Tfh1_vdjMode_BoyleLab_vdj_ref_v3","Tfh2_vdjMode_BoyleLab_vdj_ref_v3",
                     "Tfh17_vdjMode_BoyleLab_vdj_ref_v3","PD1Neg_vdjMode_BoyleLab_vdj_ref_v3")]

tfh_tcr <- tfh_tcr %>%
  purrr::map2(., file_seq, ~mutate(.x, barcode = sub(1, .y, barcode)))

#write.csv(tfh_tcr, "tfh_tcr_db_30325.csv")
```

```{r reading saved tfh csv, include= FALSE, echo=TRUE, warning=FALSE}
tfh_tcr.db <- read.csv("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/input/tfh_tcr_db_30325.csv")
tfh_tcr.db <- tfh_tcr.db[,-1]
tfh_tcr <- split(tfh_tcr.db, f= "day")
```

```{r Combine Tfh VDJ and Seurat, include=TRUE, echo=TRUE}
#Combining expression and VDJ output
tfh_rep <- combineExpression(tfh_tcr, Tfh.Map,
                             cloneCall="aa", 
                             proportion = FALSE, 
                             cloneSize=c(Single=1, Small=5, Medium=20, Large=100, Hyperexpanded=500))

tfh_rep@meta.data$integratedcluster <-  factor(tfh_rep@meta.data$integratedcluster, 
                                               levels = c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17", "Tfh1.17", "Tfreg", "IFNI", 
                                                          "heatshock", "ribosomal", "cluster2", "cluster3"))

cluster_col <- c("Tfh1" = "#9e0142", "Tfh1_CM" = "#f4a582",
                 "Tfh2" =  "#5e4fa2", "Tfh17" = "#66c2a5", 
                 "Tfh1.17" = "#e6f598", "Tfreg" = "#74add1", 
                 "IFNI" = "#8c510a", "heatshock" = "#bf812d",
                 "ribosomal"= "#fee090","cluster2" = "#01665e", "cluster3" = "#b2abd2")

cluster_orders <- c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17", "Tfh1.17", "Tfreg", "IFNI", "heatshock", "ribosomal", "cluster2", "cluster3")
```

```{r Calculating cell proportions for Tfh , include=TRUE, echo=TRUE, warning=FALSE}
cell.prop <- tfh_rep@meta.data %>% 
  mutate(TCR = case_when(is.na(CTaa) == TRUE ~ "No",
                         TRUE ~ "Yes"))

cell.prop <- cell.prop %>% 
  group_by(cloneSize) %>%
  summarise(n = n())
```

#### Figure 1 G \| Fate sharing at the individual clonotype level across transcriptional subsets.

```{r, Figure1G_Fate sharing at the individual clonotype level across transcriptional subsets, echo=TRUE,warning=FALSE, fig.width=6, fig.height=12, out.width="50%", fig.align='center'}

fidel <- tfh_rep@meta.data %>% 
  select(CTaa, integratedcluster) %>% 
  tibble::remove_rownames() %>% 
  group_by(CTaa, integratedcluster) %>% 
  summarise(n = n()) %>% 
  ungroup() %>% 
  group_by(CTaa) %>% 
  mutate(total = sum(n)) %>% 
  ungroup() %>% 
  mutate(prop = n/total) %>% 
  select(-c(n, total)) %>% 
  pivot_wider(names_from = CTaa, values_from = prop) %>% 
  arrange(., integratedcluster) %>% 
  column_to_rownames(., var = "integratedcluster") %>% 
  mutate_all(~replace(., is.na(.), 0)) %>%
  arrange()

count_per_clone <- tfh_rep@meta.data %>% 
  select(CTaa) %>% 
  tibble::remove_rownames() %>% 
  group_by(CTaa) %>% 
  summarise(n = n()) 

cluster_count <- tfh_rep@meta.data %>% 
  select(CTaa, integratedcluster) %>% 
  remove_rownames() %>% 
  group_by(integratedcluster) %>% 
  summarise(n = n()) %>% 
  mutate(prop = n/sum(n)*100) %>% 
  column_to_rownames(., var = "integratedcluster")

fidel <- as.matrix(fidel)

Heatmap((fidel),
        name = "Clonal Proportion",
        cluster_columns = T, column_dend_side = "bottom", clustering_method_columns = "ward.D2",
        cluster_rows = F,
        show_column_names = F,
        top_annotation = HeatmapAnnotation(Count = anno_barplot(
          count_per_clone$n, axis_param = list(at = c(2, 5, 12))), 
          annotation_name_rot = 90),
        width = ncol(fidel)*unit(0.05, "in"),
        height = nrow(fidel)*unit(0.6, "in"),
        col = colorRampPalette(RColorBrewer::brewer.pal(9, "Greens"))(100))  
        # Use continuous scale with 100 shades
dev.set()

```

## Figure 4

##### Reading data for Figure 4

```{r Reading data for Figure4, include=TRUE, echo=TRUE, warning=FALSE}
Tfh.IBSM <- readRDS("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/input/TfhIBSM_mappedtofullREF_reannotated_230523_v2.rds")

DefaultAssay(Tfh.IBSM) <- "integrated"
# remove cluster 13, 30, 24, 29, 23, 17 bc they are low quality clusters
Tfh.IBSM.2 <- subset(Tfh.IBSM, subset = integrated_snn_res.2.2 %in% c(0,1,2,3,4,5,6,7,8,9,10,11,12,14,15,16,18,19,20,21,22,25,26,27,28))


###### scType label..... 
# load gene set preparation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")
# load cell type annotation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")

db_ = "/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/input/TfhMap_ClusterMarkers_DB_Reannotated_postnorm_190724.xlsx";
tissue = "Immune system"

# prepare gene sets
gs_list = gene_sets_prepare(db_, tissue)

# get cell-type by cell matrix
es.max = sctype_score(scRNAseqData = Tfh.IBSM.2[["integrated"]]@scale.data, scaled = TRUE, 
                      gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)  

#write.csv(es.max, "TfhIBSM_scType_esmax_scoringpercell_310524.csv")
# merge by cluster
cL_resutls = do.call("rbind", lapply(unique(Tfh.IBSM.2@meta.data$integrated_snn_res.2.2), function(cl){
  es.max.cl = sort(rowSums(es.max[ ,rownames(Tfh.IBSM.2@meta.data[Tfh.IBSM.2@meta.data$integrated_snn_res.2.2==cl, ])]), decreasing = !0)
  head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(Tfh.IBSM.2@meta.data$integrated_snn_res.2.2==cl)), 10)
}))

sctype_scores = cL_resutls %>% group_by(cluster) %>% top_n(n = 1, wt = scores)  

write.csv(cL_resutls, "TfhIBSM_scType_clresults_scoringpercluster_310524.csv")
write.csv(sctype_scores, "TfhIBSM_scType_sctypesscore_scoringpercluster_summary_310524.csv")

# set low-confident (low ScType score) clusters to "unknown"
sctype_scores$type[as.numeric(as.character(sctype_scores$scores)) < sctype_scores$ncells/4] = "Unknown"
#print(sctype_scores[,1:3])

Tfh.IBSM.2@meta.data$customclassif = ""
for(j in unique(sctype_scores$cluster)){
  cl_type = sctype_scores[sctype_scores$cluster==j,]; 
  Tfh.IBSM.2@meta.data$customclassif[Tfh.IBSM.2@meta.data$integrated_snn_res.2.2 == j] = as.character(cl_type$type[1])
}

sctype_scores$type <- factor(sctype_scores$type, levels = c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17",
                                                            "IFNI", "heatshock", "ribo", "cluster2", "cluster3"))
cL_df <- cL_resutls
# cL_df <- read.csv("TfhIBSM_scType_cL_results_postnorm_200724.csv")
#cL_df <- cL_df[, -c(1,5)]

Tfh.IBSM.2@meta.data$customclassif <- factor(Tfh.IBSM.2@meta.data$customclassif, levels = c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17","IFNI", "heatshock", "ribo", "cluster2", "cluster3"))

Idents(object = Tfh.IBSM.2) <- "customclassif"

Tfh.IBSM.2@meta.data$seurat_clusters <- Tfh.IBSM.2@meta.data$customclassif

metadata <- as.data.frame(Tfh.IBSM.2@meta.data)
metadata$alternative_clusters <- metadata$seurat_clusters

# Assuming your metadata is in a data frame called metadata
metadata <- metadata %>%
  mutate(alternative_clusters = as.character(alternative_clusters)) %>%
  mutate(alternative_clusters = ifelse(alternative_clusters == "Tfh2" & integrated_snn_res.2.2 == 14, "Tfh1_CM", alternative_clusters))


metadata <- metadata %>%
  mutate(alternative_clusters = as.character(alternative_clusters)) %>%
  mutate(alternative_clusters = ifelse(alternative_clusters == "Tfh17" & integrated_snn_res.2.2 == 19, "cluster2", alternative_clusters))

Tfh.IBSM.2@meta.data <- metadata
#saveRDS(Tfh.IBSM.2, "Tfh.IBSM.2_REANNOTATION_POSTNORM_V2_200724.rds")
```

```{r Getting data for Figure4A_Relative expression of marker genes used to annotate reference data set in each subset in CHMI data set, echo=TRUE,warning=FALSE}
TfhIBSM <- readRDS("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/input/Tfh.IBSM.2_REANNOTATION_POSTNORM_V2_200724.rds")

DefaultAssay(TfhIBSM)
```

#### Figure 4 A \| pTfh cells (CXCR5+PD1+nnCD4 T cells) were isolated from individuals (n=4) during controlled human malaria infection (CHMI) at day 0, 8, 16 and 36. scType label transfer was used to identify Tfh transcriptional subsets using the healthy Tfh cell data set as a reference

```{r Figure 4 A |pTfh cells (CXCR5+PD1+nnCD4 T cells)scType label transfer, echo=TRUE, warning=FALSE, fig.width=10, fig.height=6, out.width="70%", fig.align='center'}
Tfh_colors_list <- c("#9e0142", "#f4a582", "#5e4fa2", "#66c2a5", "#74add1",
                     "#8c510a", "#bf812d", "#fee090", "#01665e", "#b2abd2")

TfhIBSM@meta.data$alternative_clusters <- factor(TfhIBSM@meta.data$alternative_clusters, 
                                               levels = c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17",
                                                          "Tfreg", "IFNI", "heatshock", "ribo",
                                                          "cluster2", "cluster3"))

DimPlot(TfhIBSM, group.by = "alternative_clusters", cols = Tfh_colors_list, pt.size = 2, label = T)

```

##### Calculating significant marker genes

```{r Getting data for Figure4B_Relative expression of marker genes used to annotate reference data set in each subset in CHMI data set, echo=TRUE,warning=FALSE, eval=FALSE}

# to check if lognorm has been performed... or alternatively just run each counts/data separately, logorm will be non-integers ie 1.xxx
TfhIBSM[['RNA']]@counts@x == TfhIBSM[['RNA']]@data@x

FeaturePlot(TfhIBSM, c("CXCR3")) # also confirmed lognorm has been applied.. 

FeaturePlot(TfhIBSM, c("CXCR4"), pt.size = 0.5, order = T) # also confirmed lognorm has been applied.. 

############# let's find markers for each cluster
cluster2.markers <- FindMarkers(TfhIBSM, ident.1 = "cluster2", group.by = "alternative_clusters", min.pct = 0.1, only.pos = FALSE)
cluster3.markers <- FindMarkers(TfhIBSM, ident.1 = "cluster3", group.by = "alternative_clusters", min.pct = 0.1, only.pos = FALSE)
heatshock.markers <- FindMarkers(TfhIBSM, ident.1 = "heatshock", group.by = "alternative_clusters", min.pct = 0.1, only.pos = FALSE) 
IFNI.markers <- FindMarkers(TfhIBSM, ident.1 = "IFNI", group.by = "alternative_clusters", min.pct = 0.1, only.pos = FALSE) 
ribo.markers <- FindMarkers(TfhIBSM, ident.1 = "ribo", group.by = "alternative_clusters", min.pct = 0.1, only.pos = FALSE) 
Tfh1.markers <- FindMarkers(TfhIBSM, ident.1 = "Tfh1", group.by = "alternative_clusters", min.pct = 0.1, only.pos = FALSE) 
Tfh17.markers <- FindMarkers(TfhIBSM, ident.1 = "Tfh17", group.by = "alternative_clusters", min.pct = 0.1, only.pos = FALSE) 
Tfh2.markers <- FindMarkers(TfhIBSM, ident.1 = "Tfh2", group.by = "alternative_clusters", min.pct = 0.1, only.pos = FALSE) 
Tfh1_CM.markers <- FindMarkers(TfhIBSM, ident.1 = "Tfh1_CM", group.by = "alternative_clusters", min.pct = 0.1, only.pos = FALSE) 
Tfreg.markers <- FindMarkers(TfhIBSM, ident.1 = "Tfreg", group.by = "alternative_clusters", min.pct = 0.1, only.pos = FALSE) 

##  add "neg" and "pos" to gene lists..
### can we also know how many are upregulated vs downregulated??
cluster2.markers$dir_sig[cluster2.markers$p_val_adj<0.01 & cluster2.markers$avg_log2FC>0] <-"up"
cluster2.markers$dir_sig[cluster2.markers$p_val_adj<0.01 & cluster2.markers$avg_log2FC<0] <-"down"

cluster3.markers$dir_sig[cluster3.markers$p_val_adj<0.01 & cluster3.markers$avg_log2FC>0] <-"up"
cluster3.markers$dir_sig[cluster3.markers$p_val_adj<0.01 & cluster3.markers$avg_log2FC<0] <-"down"

heatshock.markers$dir_sig[heatshock.markers$p_val_adj<0.01 & heatshock.markers$avg_log2FC>0] <-"up"
heatshock.markers$dir_sig[heatshock.markers$p_val_adj<0.01 & heatshock.markers$avg_log2FC<0] <-"down"

IFNI.markers$dir_sig[IFNI.markers$p_val_adj<0.01 & IFNI.markers$avg_log2FC>0] <-"up"
IFNI.markers$dir_sig[IFNI.markers$p_val_adj<0.01 & IFNI.markers$avg_log2FC<0] <-"down"

ribo.markers$dir_sig[ribo.markers$p_val_adj<0.01 & ribo.markers$avg_log2FC>0] <-"up"
ribo.markers$dir_sig[ribo.markers$p_val_adj<0.01 & ribo.markers$avg_log2FC<0] <-"down"

Tfh1.markers$dir_sig[Tfh1.markers$p_val_adj<0.01 & Tfh1.markers$avg_log2FC>0] <-"up"
Tfh1.markers$dir_sig[Tfh1.markers$p_val_adj<0.01 & Tfh1.markers$avg_log2FC<0] <-"down"

Tfh1_CM.markers$dir_sig[Tfh1_CM.markers$p_val_adj<0.01 & Tfh1_CM.markers$avg_log2FC>0] <-"up"
Tfh1_CM.markers$dir_sig[Tfh1_CM.markers$p_val_adj<0.01 & Tfh1_CM.markers$avg_log2FC<0] <-"down"

Tfh17.markers$dir_sig[Tfh17.markers$p_val_adj<0.01 & Tfh17.markers$avg_log2FC>0] <-"up"
Tfh17.markers$dir_sig[Tfh17.markers$p_val_adj<0.01 & Tfh17.markers$avg_log2FC<0] <-"down"

Tfh2.markers$dir_sig[Tfh2.markers$p_val_adj<0.01 & Tfh2.markers$avg_log2FC>0] <-"up"
Tfh2.markers$dir_sig[Tfh2.markers$p_val_adj<0.01 & Tfh2.markers$avg_log2FC<0] <-"down"

Tfreg.markers$dir_sig[Tfreg.markers$p_val_adj<0.01 & Tfreg.markers$avg_log2FC>0] <-"up"
Tfreg.markers$dir_sig[Tfreg.markers$p_val_adj<0.01 & Tfreg.markers$avg_log2FC<0] <-"down"
```

#### Figure 4 B \| Relative expression of marker genes used to annotate reference data set in each subset in CHMI data

```{r Figure 4B_Relative expression of marker genes used to annotate reference data set in each subset in CHMI data set, echo=TRUE,warning=FALSE, fig.width=6, fig.height=8, out.width="70%", fig.align='center'}
dotplot.genes <- c("AHNAK", "ANXA1",
                   "ZFP36", "NR4A2",
                   "JUN", "FOS",
                   "IFI44L", "IFI6", "IRF7",
                   "CTLA4", "FOXP3", "IL10RA",
                   "TGFB1", "BHLHE40", "CCR6",
                   "TCF7", "MAF", "TOX2",
                   "SELL","TIGIT", "SH2D1A", "CCR7", "IFNG", "CXCR3",
                   "NKG7", "CST7", "CCL5", "GZMK")

DotPlot_scCustom(TfhIBSM, features = dotplot.genes, colors_use = viridis_magma_dark_high, 
                 group.by = "alternative_clusters", flip_axes = T,
                x_lab_rotate = TRUE)
```

#### Figure 4 C \| Relative proportion of each pTfh transcriptional cluster during CHMI

```{r Getting data for Figure4C_Relative proportion of each pTfh transcriptional cluster during CHMI, include= TRUE, echo=TRUE,warning=FALSE}

metadata <- as.data.frame(TfhIBSM@meta.data)

try <- metadata[, c("seurat_clusters", "day", "donor_id", "alternative_clusters")]

try.4 <- try %>%
  group_by(alternative_clusters, donor_id, day) %>%   # grouping
  summarise(n = n()) %>%
  mutate(freq = n / sum(n))

try.4$donor_id <- factor(try.4$donor_id, levels = c("donor0", "donor1", "donor2", "donor3"))

try.4$day <- factor(try.4$day, levels = c("day0", "day8", "day16", "day36"))

try.4$alternative_clusters <- factor(try.4$alternative_clusters, 
                                levels = c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17","Tfh1.17",
                                           "Tfreg", "IFNI", "heatshock", "ribo",
                                           "cluster2", "cluster3"))
##Only clusters showing 
clusts = c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17")
```

```{r Figure 4C_Relative proportion of each pTfh transcriptional cluster during CHMI, echo=TRUE,warning=FALSE, fig.height=6, fig.width=10, out.width="70%", fig.align='center'}
ggplot(data = try.4, aes(x=day, y=freq)) +
  geom_line(aes(group = donor_id, colour = donor_id)) +
  geom_point(aes(group = donor_id, colour = donor_id)) + 
  geom_boxplot(data = try.4, fill = "grey", width = 0.5, outlier.shape = NA) +
  facet_wrap(~alternative_clusters, ncol = 5) + 
  theme_classic() + 
  scale_colour_manual(values = c("#d53e4f", "#3288bd", "#1a9850", "#c2a5cf"))
```

##### TCR analysis Figure 4.

```{r reading VDJ data for CHMI cohort, eval=FALSE, warning=FALSE}
setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # This only works if you are using RStudio

file.names <- list.files(pattern = 'filtered_contig_annotations.csv', recursive = TRUE)
names <- list.files(path='VDJ')

file_seq <- 1:length(file.names)

if(any(grepl("*.csv", file.names))==TRUE){
  ibsm_tcr <- file.names %>% 
    lapply(., function(i){
      fread(input = i)
    }) %>%
    setNames(names)
}

ibsm_tcr <- ibsm_tcr[mixedsort(names(ibsm_tcr))]

ibsm_tcr <- ibsm_tcr %>%
  map2(., file_seq, ~mutate(.x, barcode = sub(1, .y, barcode)))

names <- names(ibsm_tcr)

ibsm_tcr <- combineTCR(ibsm_tcr,
                       samples = names,
                       removeNA = TRUE,
                       removeMulti = TRUE,
                       filterMulti = TRUE)

## Now we need to edit the barcode, delete everything before "v3_"

ibsm_tcr <- ibsm_tcr %>% 
  map(~.x %>% mutate(barcode = gsub(".*VDJ_","",barcode)))

#write.csv(ibsm_tcr, "ibsm40_tcr_db_30325.csv")
```

```{r reading saved chmi csv, include= FALSE, echo=TRUE, warning=FALSE}
ibsm_tcr.db <- read.csv("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/input/ibsm40_tcr_db_30325.csv")
ibsm_tcr.db <- ibsm_tcr.db[,-1]
ibsm_tcr <- split(ibsm_tcr.db, f= "day")
```

##### Import Seurat

```{r Reading CHMI Seurat object, include= TRUE, echo=TRUE, warning=FALSE}
##reading seurat object 
ibsm <- readRDS("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/input/Tfh.IBSM.2_REANNOTATION_POSTNORM_V2_200724.rds")
```

##### Combine VDJ and Seurat

```{r Combine CHMI VDJ and Seurat, include= TRUE, echo=TRUE, warning=FALSE}
ibsm_rep <- combineExpression(ibsm_tcr, ibsm,
                              cloneCall="aa", 
                              proportion = FALSE,
                              cloneSize=c(Single=1, Small=5, Medium=20, Large=100, Hyperexpanded=500))

ibsm_rep@meta.data$seurat_clusters <-  factor(ibsm_rep@meta.data$seurat_clusters, 
                                              levels = c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17", "Tfh1.17", "Tfreg", "IFNI", 
                                                         "heatshock", "ribo", "cluster2", "cluster3"))

ibsm_rep@meta.data$alternative_clusters <-  factor(ibsm_rep@meta.data$alternative_clusters, 
                                              levels = c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17", "Tfh1.17", "Tfreg", "IFNI", 
                                                         "heatshock", "ribo", "cluster2", "cluster3"))

```

##### How many cells:TCR

```{r Calculating CHMI cell proportion and frequency, include= TRUE, echo=TRUE, warning=FALSE }
cell.prop <- ibsm_rep@meta.data %>% 
  mutate(TCR = case_when(is.na(CTaa) == TRUE ~ "No",
                         TRUE ~ "Yes"))

## Clonal frequency to send to Megan

clone_freq <- ibsm_rep@meta.data %>% 
  select(CTaa, clonalFrequency) %>% 
  mutate(clonalFrequency = case_when(is.na(clonalFrequency) ~ sum(is.na(CTaa)),
                                     TRUE ~ clonalFrequency))
```

##### Getting data for Figure 4D

```{r, Getting data for Figure 4D, include=TRUE, echo=TRUE, warning=FALSE}
##Setting up right colors
cluster_col <- c("Tfh1" = "#9e0142", "Tfh1_CM" = "#f4a582", "Tfh2" = "#5e4fa2", 
                 "Tfh17" = "#66c2a5", "Tfh1.17" = "#e6f598", "Tfreg" = "#74add1", 
                 "IFNI" = "#8c510a", "heatshock" = "#bf812d", "ribosomal" = "#fee090", 
                 "cluster2" = "#01665e", "cluster3" = "#b2abd2")

cluster_orders <- c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17", "Tfh1.17", "Tfreg", "IFNI", "heatshock", "ribo", "cluster2", "cluster3")

donor_col <- c("donor0"="#d53e4f", "donor1"="#3288bd", "donor2"="#1a9850", "donor3" = "#c2a5cf")

##Determine clone order
clone_order <- rev(mixedsort(unique(filter(ibsm_rep@meta.data, !is.na(cloneSize))$cloneSize)))


ibsm_rep@meta.data <- ibsm_rep@meta.data %>% 
  mutate(cloneN = case_when(clonalFrequency == 1 ~ "1",
                               clonalFrequency == 2 ~ "2",
                               clonalFrequency == 3 ~ "3",
                               clonalFrequency == 4 ~ "4",
                               clonalFrequency > 5 ~ ">5")) %>% 
  mutate(cloneN = factor(cloneN, levels = c('1','2','3','4','>5')))


ibsm_rep@meta.data <- ibsm_rep@meta.data %>% 
  mutate(cloneN2 = case_when(clonalFrequency == 1 ~ "Clone # (N=1)",
                               clonalFrequency > 1 ~ "Clone # (N>1)")) %>% 
  mutate(cloneN2 = factor(cloneN2, levels = c('Clone # (N=1)','Clone # (N>1)')),
         day = factor(day, levels = c("day0", "day8", "day16", "day36")))

RColorBrewer::brewer.pal(name = "Spectral", n = 11)

count_data <- ibsm_rep@meta.data %>%
  filter(!is.na(cloneN)) %>%
  group_by(day, donor_day, donor_id) %>% 
  count(cloneN2) %>% 
  mutate(day = factor(day, levels = c("day0","day8","day16","day36")))

p <- count_data %>% 
  group_by(cloneN2) %>% 
  wilcox_test(n ~ day, paired = F) %>% 
  add_y_position()
```

#### Figure 4 D \| Counts of clones with either a clone size = 1 or clone size = 2 across days.

```{r, Figure4D_Counts of clones with either a clone size1 or clone size2 across days. Clonal expansion was detected a day 16, warning=FALSE, fig.width=10, fig.height=6, out.width="70%", fig.align='center'}
ggplot(count_data, aes(x = day, y = n)) +
  stat_summary(fun=sum, geom="bar", fill = "white", color = "black")+
  theme_classic() +
  # scale_fill_manual(values = c("grey","#ABDDA4", "#66C2A5", "#3288BD", "#5E4FA2")) +
  labs(y = "Count") +
  theme(axis.title.x = element_blank(), axis.text.x = element_text(angle = 90)) +
  facet_wrap(~cloneN2) +
  stat_pvalue_manual(p, label = "p", hide.ns = "p")
```

#### Figure 4 E \| Clone family size count over time in each subset - Clonal expansion was detected in Tfh1_cyto, Tfh1_CCR7 and Tfh2 clusters at day 16

```{r, Figure4E_Clone family size count over time in each subset, warning=FALSE, fig.width=10, fig.height=6, out.width="70%", fig.align='center'}
ggplot(filter(ibsm_rep@meta.data, !is.na(cloneN)), 
       aes(x = alternative_clusters, fill = cloneN))+
  geom_bar(colour = "black", position = position_stack(reverse = TRUE), linewidth = 0.3)+
  # geom_text(stat='count', aes(label= ..count..), vjust=-1)+
  # scale_x_discrete(limits = clone_order)+
  theme_classic()+
  # scale_fill_brewer(palette = "GnBu", direction = 1)+
  scale_fill_manual(values = c("grey","#ABDDA4", "#66C2A5", "#3288BD", "#5E4FA2"))+
  labs(y = "Count")+
  theme(axis.title.x = element_blank(),
        axis.text.x = element_text(angle=90))+
  facet_wrap(~day, nrow = 1)
```

##### Calculating Simpsons diversity Index in each donor across time

Create a diversity plot for donor_day (per donor and all donor overtime)

NOTE: scRepertoire exportTable output generating WRONG output by rounding off data to whole number. E.g. diversity 0.99 or 0.97 will be rounded off to 1 in exportTable. This is INCORRECT. The plots however, generate the correct diversity index values.

Use this guide from 10x <https://kb.10xgenomics.com/hc/en-us/articles/13303807883405-How-to-calculate-paired-clonotype-diversity>

```{r Getting data for Figure4F, include=TRUE, echo=TRUE, warning=FALSE}
## We need to downsample first
count <- ibsm_rep@meta.data %>% 
  filter(., !is.na(CTaa)) %>% 
  filter(., donor_id != "donor2" | day != "day8") %>% 
  group_by(donor_day) %>% 
  summarise(n = n()) 
min_count <- min(count$n)

set.seed(123)
ibsm_div_day <- ibsm_rep@meta.data %>% 
  filter(., !is.na(CTaa)) %>% 
  group_by(donor_day) %>% 
  slice_sample(., n = 1000) %>%
  group_by(CTaa, day, donor_id) %>%
  summarise(freq=n()) %>%
  group_by(day, donor_id) %>% 
  mutate(sum = sum(freq),
         prop = freq/sum,
         abn = prop^2) %>% 
  summarise(diversity = sum(abn)) %>% 
  mutate(day = factor(day, levels = c("day0","day8","day16","day36"))) %>% 
  filter(., donor_id != "donor2" | day != "day8")
```

#### Figure 4 F \| Simpsons diversity Index in each donor across time

```{r Figure4F_Simpsons diversity Index in each donor across time,warning=FALSE, fig.width=4, fig.height=3.5, out.width="70%", fig.align='center'}
ggplot(ibsm_div_day, aes(x = day, y = diversity, color = donor_id))+
  geom_line(aes(group = donor_id))+
  geom_point(size = 2)+
  theme_classic()+
  ylab("Simpson's Diversity Index")+
  scale_color_manual(values = donor_col)
```

#### Figure 4 G \| Clonal overlap at day 16 across clusters. Clonal size is indicated in count in top bar, each clonal proportion across subsets is indicated.

```{r Getting data for Figure4G, include=TRUE, echo=TRUE, warning=FALSE}
##subset to clonal frequency higher than 1
ibsm_rep <- subset(ibsm_rep, subset = clonalFrequency != 1)
```

```{r Figure 4G_Clonal overlap at day 16 across clusters. Clonal size is indicated in count in top bar, each clonal proportion across subsets is indicated, include=TRUE, warning=FALSE, fig.width=20, fig.height=10, out.width="70%", fig.align='center'}
for (i in unique(ibsm_rep@meta.data$day)){
  fidel <- ibsm_rep@meta.data %>% 
    filter(., day == i) %>% 
    select(CTaa, alternative_clusters) %>% 
    tibble::remove_rownames() %>% 
    group_by(CTaa, alternative_clusters) %>% 
    summarise(n = n()) %>% 
    ungroup() %>% 
    group_by(CTaa) %>% 
    mutate(total = sum(n)) %>% 
    ungroup() %>% 
    mutate(prop = n/total) %>% 
    select(-c(n, total)) %>% 
    pivot_wider(names_from = CTaa, values_from = prop) %>% 
    arrange(., alternative_clusters) %>% 
    column_to_rownames(., var = "alternative_clusters") %>% 
    mutate_all(~replace(., is.na(.), 0)) %>%
    arrange()

  count_per_clone <- ibsm_rep@meta.data %>% 
    filter(., day == i) %>% 
    select(CTaa) %>% 
    tibble::remove_rownames() %>% 
    group_by(CTaa) %>% 
    summarise(n = n()) 
  max_count <- max(count_per_clone$n)

  cluster_count <- ibsm_rep@meta.data %>% 
    filter(., day == i) %>% 
    select(CTaa, alternative_clusters) %>% 
    remove_rownames() %>% 
    group_by(alternative_clusters) %>% 
    summarise(n = n()) %>% 
    mutate(prop = n/sum(n)*100) %>% 
    column_to_rownames(., var = "alternative_clusters")

  fidel <- as.matrix(fidel)

  print(Heatmap((fidel),
          column_title = paste0(i),
          name = "Clonal Proportion",
          cluster_columns = T, column_dend_side = "bottom", clustering_method_columns = "ward.D2",
          cluster_rows = F,
          show_column_names = F,
          # left_annotation = rowAnnotation(Prop = anno_barplot(
          #   cluster_count$prop, axis_param = list(direction = "reverse")),
          #                                                   annotation_name_rot = 90),
          top_annotation = HeatmapAnnotation(Count = anno_barplot(
            count_per_clone$n, axis_param = list(at = c(2, 5, max_count))), 
            annotation_name_rot = 90),
          # rect_gp = gpar(col = "white", lwd = 0.5),
          width = ncol(fidel)*unit(0.05, "in"),
          height = nrow(fidel)*unit(0.6, "in"),
          col = colorRampPalette(RColorBrewer::brewer.pal(9, "Greens"))(100))
  )
          # Use continuous scale with 100 shades
  dev.set()
}


```

## Figure 5

##### Differential expression analysis
This workflow was follow from https://github.com/hbc/knowledgebase/blob/master/scrnaseq/pseudobulkDE_edgeR.md

```{r differential expression analysis, eval=FALSE, warning=FALSE}
TfhIBSM <- readRDS("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/input/Tfh.IBSM.2_REANNOTATION_POSTNORM_V2_200724.rds")

TfhIBSM@meta.data$alternative_clusters <- factor(TfhIBSM@meta.data$alternative_clusters, 
                                            levels = c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17","Tfh1.17",
                                                       "Tfreg", "IFNI", "heatshock", "ribo",
                                                       "cluster2", "cluster3"))

##Functions that will be needed
dMcast<-function(data,formula,fun.aggregate='sum',value.var=NULL,as.factors=FALSE,factor.nas=TRUE,drop.unused.levels=TRUE)
{
  values<-1
  if(!is.null(value.var))
    values<-data[,value.var]
  alltms<-terms(formula,data=data)
  response<-rownames(attr(alltms,'factors'))[attr(alltms,'response')]
  tm<-attr(alltms,"term.labels")
  interactionsIndex<-grep(':',tm)
  interactions<-tm[interactionsIndex]
  simple<-setdiff(tm,interactions)
  i2<-strsplit(interactions,':')
  newterms<-unlist(lapply(i2,function (x) paste("paste(",paste(x,collapse=','),",","sep='_'",")")))
  newterms<-c(simple,newterms)
  newformula<-as.formula(paste('~0+',paste(newterms,collapse='+')))
  allvars<-all.vars(alltms)
  data<-data[,c(allvars),drop=FALSE]
  if(as.factors)
    data<-data.frame(lapply(data,as.factor))
  characters<-unlist(lapply(data,is.character))
  data[,characters]<-lapply(data[,characters,drop=FALSE],as.factor)
  factors<-unlist(lapply(data,is.factor))
  #Prevents errors with 1 or fewer distinct levels
  data[,factors]<-lapply(data[,factors,drop=FALSE],function (x) 
  {
    if(factor.nas)
      if(any(is.na(x)))
      {
        levels(x)<-c(levels(x),'NA')
        x[is.na(x)]<-'NA'
      }
    if(drop.unused.levels)
      if(nlevels(x)!=length(na.omit(unique(x))))
        x<-factor(as.character(x))
    y<-contrasts(x,contrasts=FALSE,sparse=TRUE)
    attr(x,'contrasts')<-y
    return(x)
  })
  #Allows NAs to pass
  attr(data,'na.action')<-na.pass
  result<-sparse.model.matrix(newformula,data,drop.unused.levels = FALSE,row.names=FALSE)
  brokenNames<-grep('paste(',colnames(result),fixed = TRUE)
  colnames(result)[brokenNames]<-lapply(colnames(result)[brokenNames],function (x) {
    x<-gsub('paste(',replacement='',x=x,fixed = TRUE) 
    x<-gsub(pattern=', ',replacement='_',x=x,fixed=TRUE) 
    x<-gsub(pattern='_sep = \"_\")',replacement='',x=x,fixed=TRUE)
    return(x)
  })
  
  result<-result*values
  if(isTRUE(response>0))
  {
    responses=all.vars(terms(as.formula(paste(response,'~0'))))
    result<-aggregate.Matrix(result,data[,responses,drop=FALSE],fun=fun.aggregate)
  }
  return(result)
}

##Second function
aggregate.Matrix<-function(x,groupings=NULL,form=NULL,fun='sum',...)
{
  if(!is(x,'Matrix'))
    x<-Matrix(as.matrix(x),sparse=TRUE)
  if(fun=='count')
    x<-x!=0
  groupings2<-groupings
  if(!is(groupings2,'data.frame'))
    groupings2<-as(groupings2,'data.frame')
  groupings2<-data.frame(lapply(groupings2,as.factor))
  groupings2<-data.frame(interaction(groupings2,sep = '_'))
  colnames(groupings2)<-'A'
  if(is.null(form))
    form<-as.formula('~0+.')
  form<-as.formula(form)
  mapping<-dMcast(groupings2,form)
  colnames(mapping)<-substring(colnames(mapping),2)
  result<-t(mapping) %*% x
  if(fun=='mean')
    result@x<-result@x/(aggregate.Matrix(x,groupings2,fun='count'))@x
  attr(result,'crosswalk')<-grr::extract(groupings,match(rownames(result),groupings2$A))
  return(result)
}
#### Day 0 vs Day 8 ####


Tfh.8 <- subset(TfhIBSM, subset = day %in% c("day0", "day8"))
table(Tfh.8@meta.data$day)
#### Redefining orders for days and donor_days


Tfh.8@meta.data$day <- factor(Tfh.8@meta.data$day, levels = c("day0", "day8"))

Tfh.8@meta.data$day_donor <- paste(Tfh.8@meta.data$day, Tfh.8@meta.data$donor_id, sep="_")

table(Tfh.8@meta.data$day_donor)

Tfh.8@meta.data$day_donor <- factor(Tfh.8@meta.data$day_donor, 
                                    levels = c("day0_donor0", "day0_donor1", "day0_donor2", "day0_donor3",
                                               "day8_donor0", "day8_donor1", "day8_donor2", "day8_donor3"))


Idents(Tfh.8) <- "alternative_clusters"
DimPlot(Tfh.8, group.by = "ident", cols = Tfh_colors_list, pt.size = 2, label = T)
table(Tfh.8@meta.data$alternative_clusters)

#Extract Counts and Metadata
# Extract raw counts and metadata to create SingleCellExperiment object
counts <- GetAssayData(object = Tfh.8, layer = "counts", assay="RNA")
metadata <- Tfh.8@meta.data

#Set up metadata as desired for aggregation and DE analysis
metadata$cluster_id <- factor(Tfh.8@active.ident)
table(metadata$cluster_id)

# Create single cell experiment object
sce <- SingleCellExperiment(assays = list(counts = counts),
                            colData = metadata)


## Explore the cellular metadata for the dataset
### (number of cells) * (number of meta columns)
dim(colData(sce)) 



#Explore the counts data

#Explore the raw counts for the dataset
## Check the assays present (only counts)
assays(sce)


#Explore the raw counts for the dataset
### (genes) * (cells)
dim(counts(sce))  

counts(sce)[1:6, 1:6]

#Additional QC filtering
## Remove lowly expressed genes which have less than 10 cells with any counts
sce <- sce[rowSums(counts(sce) > 1) >= 10, ]

# (genes) x (cells)
dim(sce)
# 9252 genes... 

#Preparing data for count aggregation
# Named vector of cluster names =
## 10
kids <- purrr::set_names(levels(sce$cluster_id))

# Total number of clusters
## 10
nk <- length(kids)

# Named vector of sample names
sids <- purrr::set_names(levels(as.factor(sce$day_donor)))


# Total number of samples = donor_id 
## 16
ns <- length(sids)

# Generate sample level metadata

## Determine the number of cells per sample
#table(sce$day_donor)

## Turn class "table" into a named vector of cells per sample
n_cells <- table(sce$day_donor) %>%  as.vector()
names(n_cells) <- names(table(sce$day_donor))

## Match the named vector with metadata to combine it
m <- match(names(n_cells), sce$day_donor)

## Create the sample level metadata by selecting specific columns
ei <- data.frame(colData(sce)[m, ], 
                 n_cells, row.names = NULL) %>% 
  dplyr::select("day_donor", "day", "n_cells")
kable(ei)

## Count aggregation

# Aggregate the counts per sample_id and cluster_id

# Subset metadata to only include the cluster and sample IDs to aggregate across
groups <- colData(sce)[, c("cluster_id", "day_donor")]
groups$day_donor <- factor(groups$day_donor)

# Aggregate across cluster-sample groups
# Each row corresponds to aggregate counts for a cluster-sample combo
pb <- aggregate.Matrix(t(counts(sce)), 
                       groupings = groups, fun = "sum") 

# class(pb)
# dim(pb)
pb[1:8, 1:8]


## Split/subsetting

# Here, we split the aggregated matrix into a matrix for each cluster. 
# In the table below, we report the total number of cells in each sample correposnding to each cluster

# create a vector that represents how to split samples
splitf <- sapply(stringr::str_split(rownames(pb), 
                                    pattern = "_day",n = 2), `[`, 1)


# Split data and turn into a list
# Each component corresponds to a cluster; storing associated expression matrix (counts)
# Transform data i.e, so rows are genes and columns are samples 
pb <- split.data.frame(pb,factor(splitf)) %>%
  lapply(function(u) 
    set_colnames(t(u), gsub(".*_da", "", rownames(u))))

# Explore the different components of list
class(pb)
str(pb)

###Print cluster-sample table

options(width = 100)
kable(table(sce$cluster_id, sce$day_donor))

## Starting EdgeR Analysis

#Subset Clusters

### construct SCE of pseudo-bulk counts for only select clusters
# If you are interested in all clusters AND you have the same samples represented in each cluster you can just use pb

#Note: We want all clusters and already remove cluster 8 at the beginning.

## Select the cluster you're interested?? no option to use pb directly without subsetting
dim(pb$Tfh1)
dim(pb$Tfh2)
dim(pb$Tfh17)
dim(pb$Tfh1_CM)
dim(pb$Tfreg)
dim(pb$IFNI)
dim(pb$heatshock)
dim(pb$ribo)
dim(pb$cluster2)
dim(pb$cluster3)

# Create a character vector of the clusters to use for DE
keepClusters <- as.character(c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17","Tfreg", "IFNI", "heatshock", "ribo", "cluster3", "cluster2"))
# Subset the sce object
pbc <- SingleCellExperiment(assays = pb[keepClusters])

# MDS plots
# Similar to a PCA plot, the MDS allows us to visulize the distances between samples 
# for each cluster. Ideally we'd like "het" samples to segregate together and "ko" together.

# compute MDS coordinates
mds <-  lapply(as.list(assays(pbc)), function(a){
  DGEList(a, remove.zeros = TRUE) %>% 
    calcNormFactors %>% 
    plotMDS.DGEList(plot = FALSE)
})  


# Add cluster names
cnames <- paste("Cluster", keepClusters)
for (m in 1:length(mds)){
  mds[[m]]$cluster <- cnames[m]
}


# prep. data.frame for plotting
plots <- lapply(mds, function(m){
  gg_df <<- data.frame(m[c("x", "y")],
                       sample_id = sids,
                       group_id = ei$day_donor,
                       cluster_id = rep(m$cluster, length(m$x)))})

# Create a plotting function
plotFunc <- function(x) {
  ggplot(x, aes(x, y, col = group_id)) + 
    geom_point(size = 3, alpha = 0.8) +
    labs(x = "MDS dim. 1", y = "MDS dim. 2") + 
    ggtitle(unique(x$cluster_id)) + 
    theme_bw() +
    theme(panel.grid.minor = element_blank(),
          plot.title = element_text(hjust = 0.5)) +
    coord_fixed() 
}


plotFunc2 <- function(x) {
  ggplot(x, aes(x, y, col = group_id)) + 
    geom_point(size = 3, alpha = 0.8) +
    scale_colour_manual(values = c("#542788","#8073ac", "#b2abd2", "#d8daeb",
                                   "#b35806", "#e08214", "#fdb863", "#fee0b6")) +
    labs(x = "MDS dim. 1", y = "MDS dim. 2") + 
    ggtitle(unique(x$cluster_id)) + 
    theme_bw() +
    theme(panel.grid.minor = element_blank(),
          plot.title = element_text(hjust = 0.5)) +
    coord_fixed() 
}

# Plot all MDS plots
do.call(grid.arrange,c(lapply(plots, plotFunc)))
# plotting again but colouring by days (day 0 - purple, day 16 - orange)
do.call(grid.arrange,c(lapply(plots, plotFunc2)))

mds_d8<- do.call(grid.arrange,c(lapply(plots, plotFunc2)))

# Run differential expression analysis
#First set up the experiment design and a contrast matrix.

# construct design & contrast matrix

(design <- model.matrix(~ 0 + ei$day) %>% 
   set_rownames(ei$day_donor) %>% 
   set_colnames(levels(factor(ei$day))))

# A positive FC is increased expression in the ko compared to het
(contrast <- makeContrasts("day0-day8", levels = design))
# day 0: 1; day8: -1
set.seed(12345)
# for ea. cluster, run edgeR w/ default parameters
res <- lapply(keepClusters, function(k) {
  y <- assays(pbc)[[k]]
  y <- DGEList(y, remove.zeros = TRUE)
  y <- calcNormFactors(y)
  y <- estimateDisp(y, design)
  fit <- glmQLFit(y, design)
  fit <- glmQLFTest(fit, contrast = contrast)
  topTags(fit, n = Inf, sort.by = "none")$table %>% 
    dplyr::mutate(gene = rownames(.), cluster_id = k) %>% 
    dplyr::rename(p_val = PValue, p_adj = FDR)
})

# Results filtering & overview

# filter FDR < 0.05, |logFC| > 1 & sort by FDR
res_fil <- lapply(res, 
                  function(u)  u %>% 
                    dplyr::filter(p_adj < 0.05, abs(logFC) > 1) %>% 
                    dplyr::arrange(p_adj))


# Significant genes
# We filter the results with the criteria FDR < 0.05, and |logFC| > 1. 
# For each cluster we report the number of differentially expressed genes and what percentage that represents (of total genes).

## Count the number of differential findings by cluster.
# nb. & % of DE genes per cluster
n_de <- vapply(res_fil, nrow, numeric(1))
cbind(cluster=keepClusters, numDE_genes=n_de, 
      percentage = round(n_de / nrow(pbc) * 100, digits =2)) %>%  kable()

##Write results to file

for(cluster in 1:length(keepClusters)){
  # Full results
  filePath <- paste0("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/", keepClusters[cluster])
  out <- res[[cluster]][,c("gene", "logFC", "logCPM", "F", "p_val", "p_adj")]
  write.csv(out, file = paste0(filePath,"_", "D0D8_edgeR_pseudobulk_Allresults_240724_ALTERNATIVE.csv"), quote=F, row.names = F)
  
  # Sig genes
  filePath <- paste0("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/", keepClusters[cluster])
  out <- res_fil[[cluster]][,c("gene", "logFC", "logCPM", "F", "p_val", "p_adj")]
  write.csv(out, file = paste0(filePath,"_", "D0D8_edgeR_pseudobulk_sigGenes_240724_ALTERNATIVE.csv"), quote=F, row.names = F)
  
}

#### Day 0 vs Day 16 ####

#SUBSET FOR DAY COMPARISONS YOU WANT
Tfh.16 <- subset(TfhIBSM, subset = day %in% c("day0", "day16"))
table(Tfh.16@meta.data$day)
#Redefining orders for days and donor_days

Tfh.16@meta.data$day <- factor(Tfh.16@meta.data$day, levels = c("day0", "day16"))

Tfh.16@meta.data$day_donor <- paste(Tfh.16@meta.data$day, Tfh.16@meta.data$donor_id, sep="_")

table(Tfh.16@meta.data$day_donor)

Tfh.16@meta.data$day_donor <- factor(Tfh.16@meta.data$day_donor, 
                                     levels = c("day0_donor0", "day0_donor1", "day0_donor2", "day0_donor3",
                                                "day16_donor0", "day16_donor1", "day16_donor2", "day16_donor3"))
Idents(Tfh.16) <- "alternative_clusters"
DimPlot(Tfh.16, group.by = "ident", cols = Tfh_colors_list, pt.size = 2, label = T)
table(Tfh.16@meta.data$alternative_clusters)

# Extract Counts and Metadata
# Extract raw counts and metadata to create SingleCellExperiment object
counts <- GetAssayData(object = Tfh.16, layer = "counts", assay="RNA")
metadata <- Tfh.16@meta.data

#Set up metadata as desired for aggregation and DE analysis
metadata$cluster_id <- factor(Tfh.16@active.ident)
table(metadata$cluster_id)

# Create single cell experiment object
sce <- SingleCellExperiment(assays = list(counts = counts),
                            colData = metadata)
## Explore the cellular metadata for the dataset
### (number of cells) * (number of meta columns)
dim(colData(sce)) 

#Explore the counts data
#Starting EdgeR Analysis

# Subset Clusters 

# construct SCE of pseudo-bulk counts for only select clusters
# If you are interested in all clusters AND you have the same samples represented in each cluster you can just use pb

#Note: We want all clusters and already remove cluster 8 at the beginning.

## Select the cluster you're interested?? no option to use pb directly without subsetting
dim(pb$Tfh1)
dim(pb$Tfh2)
dim(pb$Tfh17)
dim(pb$Tfh1_CM)
dim(pb$Tfreg)
dim(pb$IFNI)
dim(pb$heatshock)
dim(pb$ribo)
dim(pb$cluster2)
dim(pb$cluster3)

# Create a character vector of the clusters to use for DE
keepClusters <- as.character(c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17", "Tfreg", "IFNI", "heatshock", "ribo", "cluster3", "cluster2"))
# Subset the sce object - I use all.
pbc <- SingleCellExperiment(assays = pb)

#MDS plots
# Similar to a PCA plot, the MDS allows us to visulize the distances between samples 
# for each cluster. Ideally we'd like "het" samples to segregate together and "ko" together.

# compute MDS coordinates
mds <-  lapply(as.list(assays(pbc)), function(a){
  DGEList(a, remove.zeros = TRUE) %>% 
    calcNormFactors %>% 
    plotMDS.DGEList(plot = FALSE)
})  


# Add cluster names
cnames <- paste("Cluster", keepClusters)
for (m in 1:length(mds)){
  mds[[m]]$cluster <- cnames[m]
}


# prep. data.frame for plotting
plots <- lapply(mds, function(m){
  gg_df <<- data.frame(m[c("x", "y")],
                       sample_id = sids,
                       group_id = ei$day_donor,
                       cluster_id = rep(m$cluster, length(m$x)))})

# Create a plotting function
plotFunc <- function(x) {
  ggplot(x, aes(x, y, col = group_id)) + 
    geom_point(size = 3, alpha = 0.8) +
    labs(x = "MDS dim. 1", y = "MDS dim. 2") + 
    ggtitle(unique(x$cluster_id)) + 
    theme_bw() +
    theme(panel.grid.minor = element_blank(),
          plot.title = element_text(hjust = 0.5)) +
    coord_fixed() 
}

plotFunc2 <- function(x) {
  ggplot(x, aes(x, y, col = group_id)) + 
    geom_point(size = 3, alpha = 0.8) +
    scale_colour_manual(values = c("#542788","#8073ac", "#b2abd2", "#d8daeb",
                                   "#b35806", "#e08214", "#fdb863", "#fee0b6")) +
    labs(x = "MDS dim. 1", y = "MDS dim. 2") + 
    ggtitle(unique(x$cluster_id)) + 
    theme_bw() +
    theme(panel.grid.minor = element_blank(),
          plot.title = element_text(hjust = 0.5)) +
    coord_fixed() 
}

# Plot all MDS plots
do.call(grid.arrange,c(lapply(plots, plotFunc)))
# plotting again but colouring by days (day 0 - purple, day 16 - orange)
do.call(grid.arrange,c(lapply(plots, plotFunc2)))

mds_d16<- do.call(grid.arrange,c(lapply(plots, plotFunc2)))

# Run differential expression analysis
#First set up the experiment design and a contrast matrix.

# construct design & contrast matrix

(design <- model.matrix(~ 0 + ei$day) %>% 
   set_rownames(ei$day_donor) %>% 
   set_colnames(levels(factor(ei$day))))

# A positive FC is increased expression in the ko compared to het (ko-ket)
(contrast <- makeContrasts("day0-day16", levels = design))
# so here, day 0: is postive; day16: is negative. 
set.seed(12345)
# for ea. cluster, run edgeR w/ default parameters
res <- lapply(keepClusters, function(k) {
  y <- assays(pbc)[[k]]
  y <- DGEList(y, remove.zeros = TRUE)
  y <- calcNormFactors(y)
  y <- estimateDisp(y, design)
  fit <- glmQLFit(y, design)
  fit <- glmQLFTest(fit, contrast = contrast)
  topTags(fit, n = Inf, sort.by = "none")$table %>% 
    dplyr::mutate(gene = rownames(.), cluster_id = k) %>% 
    dplyr::rename(p_val = PValue, p_adj = FDR)
})

# Results filtering & overview

# filter FDR < 0.05, |logFC| > 1 & sort by FDR
res_fil <- lapply(res, 
                  function(u)  u %>% 
                    dplyr::filter(p_adj < 0.05, abs(logFC) > 1) %>% 
                    dplyr::arrange(p_adj))

#Significant genes 
# We filter the results with the criteria FDR < 0.05, and |logFC| > 1. 
# For each cluster we report the number of differentially expressed genes and what percentage that represents (of total genes).

## Count the number of differential findings by cluster.
# nb. & % of DE genes per cluster
n_de <- vapply(res_fil, nrow, numeric(1))
cbind(cluster=keepClusters, numDE_genes=n_de, 
      percentage = round(n_de / nrow(pbc) * 100, digits =2)) %>%  kable()

##Write results to file

for(cluster in 1:length(keepClusters)){
  # Full results
  filePath <- paste0("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/", keepClusters[cluster])
  out <- res[[cluster]][,c("gene", "logFC", "logCPM", "F", "p_val", "p_adj")]
  write.csv(out, file = paste0(filePath,"_", "D0D16_edgeR_pseudobulk_Allresults_240724_ALTERNATIVE.csv"), quote=F, row.names = F)
  
  # Sig genes
  filePath <- paste0("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/", keepClusters[cluster])
  out <- res_fil[[cluster]][,c("gene", "logFC", "logCPM", "F", "p_val", "p_adj")]
  write.csv(out, file = paste0(filePath,"_", "D0D16_edgeR_pseudobulk_sigGenes_240724_ALTERNATIVE.csv"), quote=F, row.names = F)
  
}

#### Day 0 vs Day 36 ####

Tfh.36 <- subset(TfhIBSM, subset = day %in% c("day0", "day36"))
table(Tfh.36@meta.data$day)
#### Redefining orders for days and donor_days


Tfh.36@meta.data$day <- factor(Tfh.36@meta.data$day, levels = c("day0", "day36"))

Tfh.36@meta.data$day_donor <- paste(Tfh.36@meta.data$day, Tfh.36@meta.data$donor_id, sep="_")

table(Tfh.36@meta.data$day_donor)

Tfh.36@meta.data$day_donor <- factor(Tfh.36@meta.data$day_donor, 
                                     levels = c("day0_donor0", "day0_donor1", "day0_donor2", "day0_donor3",
                                                "day36_donor0", "day36_donor1", "day36_donor2", "day36_donor3"))


Idents(Tfh.36) <- "alternative_clusters"
DimPlot(Tfh.36, group.by = "ident", cols = Tfh_colors_list, pt.size = 2, label = T)
table(Tfh.36@meta.data$alternative_clusters)

#Extract Counts and Metadata
# Extract raw counts and metadata to create SingleCellExperiment object
counts <- GetAssayData(object = Tfh.36, slot = "counts", assay="RNA")
metadata <- Tfh.36@meta.data

#Set up metadata as desired for aggregation and DE analysis
metadata$cluster_id <- factor(Tfh.36@active.ident)
table(metadata$cluster_id)

# Create single cell experiment object
sce <- SingleCellExperiment(assays = list(counts = counts),
                            colData = metadata)

## Explore the cellular metadata for the dataset
### (number of cells) * (number of meta columns)
dim(colData(sce)) 


#Explore the counts data

#Explore the raw counts for the dataset
#Check the assays present (only counts)
assays(sce)

#Explore the raw counts for the dataset

dim(counts(sce))  

counts(sce)[1:6, 1:6]

#Additional QC filtering
## Remove lowly expressed genes which have less than 10 cells with any counts
sce <- sce[rowSums(counts(sce) > 1) >= 10, ]

# (genes) x (cells)
dim(sce)

#Preparing data for count aggregation
# Named vector of cluster names =
## 10
kids <- purrr::set_names(levels(sce$cluster_id))

# Total number of clusters
## 10
nk <- length(kids)

# Named vector of sample names
sids <- purrr::set_names(levels(as.factor(sce$day_donor)))

# Total number of samples = donor_id 
## 16
ns <- length(sids)

# Generate sample level metadata

# Determine the number of cells per sample
#table(sce$day_donor)

## Turn class "table" into a named vector of cells per sample
n_cells <- table(sce$day_donor) %>%  as.vector()
names(n_cells) <- names(table(sce$day_donor))

## Match the named vector with metadata to combine it
m <- match(names(n_cells), sce$day_donor)

## Create the sample level metadata by selecting specific columns
ei <- data.frame(colData(sce)[m, ], 
                 n_cells, row.names = NULL) %>% 
  dplyr::select("day_donor", "day", "n_cells")
kable(ei)

# Count aggregation 

# Aggregate the counts per sample_id and cluster_id

# Subset metadata to only include the cluster and sample IDs to aggregate across
groups <- colData(sce)[, c("cluster_id", "day_donor")]
groups$day_donor <- factor(groups$day_donor)

# Aggregate across cluster-sample groups
# Each row corresponds to aggregate counts for a cluster-sample combo
pb <- aggregate.Matrix(t(counts(sce)), 
                       groupings = groups, fun = "sum") 

# class(pb)
# dim(pb)
pb[1:8, 1:8]


#Split/subsetting
##Here, we split the aggregated matrix into a matrix for each cluster. 
##In the table below, we report the total number of cells in each sample correposnding to each cluster

# create a vector that represents how to split samples
splitf <- sapply(stringr::str_split(rownames(pb), 
                                    pattern = "_day",n = 2), `[`, 1)

# Split data and turn into a list
# Each component corresponds to a cluster; storing associated expression matrix (counts)
# Transform data i.e, so rows are genes and columns are samples 
pb <- split.data.frame(pb,factor(splitf)) %>%
  lapply(function(u) 
    set_colnames(t(u), gsub(".*_da", "", rownames(u))))

# Explore the different components of list
class(pb)
str(pb)

###Print cluster-sample table

options(width = 100)
kable(table(sce$cluster_id, sce$day_donor))

#Starting EdgeR Analysis

#Subset Clusters

#construct SCE of pseudo-bulk counts for only select clusters
# If you are interested in all clusters AND you have the same samples represented in each cluster you can just use pb

#Note: We want all clusters and already remove cluster 8 at the beginning.

## Select the cluster you're interested?? no option to use pb directly without subsetting
dim(pb$Tfh1)

dim(pb$Tfh2)

dim(pb$Tfh17)

dim(pb$Tfh1_CM)

dim(pb$Tfreg)

dim(pb$IFNI)

dim(pb$heatshock)

dim(pb$ribo)

dim(pb$cluster2)

dim(pb$cluster3)

# Create a character vector of the clusters to use for DE
keepClusters <- as.character(c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17", "Tfreg", "IFNI", "heatshock", "ribo", "cluster2", "cluster3"))
# Subset the sce object
pbc <- SingleCellExperiment(assays = pb[keepClusters])

# MDS plots
# Similar to a PCA plot, the MDS allows us to visulize the distances between samples 
# for each cluster. Ideally we'd like "het" samples to segregate together and "ko" together.

# compute MDS coordinates
mds <-  lapply(as.list(assays(pbc)), function(a){
  DGEList(a, remove.zeros = TRUE) %>% 
    calcNormFactors %>% 
    plotMDS.DGEList(plot = FALSE)
})  


# Add cluster names
cnames <- paste("Cluster", keepClusters)
for (m in 1:length(mds)){
  mds[[m]]$cluster <- cnames[m]
}

# prep. data.frame for plotting
plots <- lapply(mds, function(m){
  gg_df <<- data.frame(m[c("x", "y")],
                       sample_id = sids,
                       group_id = ei$day_donor,
                       cluster_id = rep(m$cluster, length(m$x)))})

# Create a plotting function
plotFunc <- function(x) {
  ggplot(x, aes(x, y, col = group_id)) + 
    geom_point(size = 3, alpha = 0.8) +
    labs(x = "MDS dim. 1", y = "MDS dim. 2") + 
    ggtitle(unique(x$cluster_id)) + 
    theme_bw() +
    theme(panel.grid.minor = element_blank(),
          plot.title = element_text(hjust = 0.5)) +
    coord_fixed() 
}


plotFunc2 <- function(x) {
  ggplot(x, aes(x, y, col = group_id)) + 
    geom_point(size = 3, alpha = 0.8) +
    scale_colour_manual(values = c("#542788","#8073ac", "#b2abd2", "#d8daeb",
                                   "#b35806", "#e08214", "#fdb863", "#fee0b6")) +
    labs(x = "MDS dim. 1", y = "MDS dim. 2") + 
    ggtitle(unique(x$cluster_id)) + 
    theme_bw() +
    theme(panel.grid.minor = element_blank(),
          plot.title = element_text(hjust = 0.5)) +
    coord_fixed() 
}

# Plot all MDS plots
do.call(grid.arrange,c(lapply(plots, plotFunc)))
# plotting again but colouring by days (day 0 - purple, day 16 - orange)
do.call(grid.arrange,c(lapply(plots, plotFunc2)))

mds_d36<- do.call(grid.arrange,c(lapply(plots, plotFunc2)))

ggsave(plot = mds_d36, filename = "MDSplots_d36_ALTERNATIVE_240724.pdf",
       width = 420, height= 297, units = "mm", device = "pdf" )

# Run differential expression analysis
#First set up the experiment design and a contrast matrix.

# construct design & contrast matrix

(design <- model.matrix(~ 0 + ei$day) %>% 
   set_rownames(ei$day_donor) %>% 
   set_colnames(levels(factor(ei$day))))

# A positive FC is increased expression in the ko compared to het
(contrast <- makeContrasts("day0-day36", levels = design))
# day 0: 1; day36: -1
set.seed(12345)
# for ea. cluster, run edgeR w/ default parameters
res <- lapply(keepClusters, function(k) {
  y <- assays(pbc)[[k]]
  y <- DGEList(y, remove.zeros = TRUE)
  y <- calcNormFactors(y)
  y <- estimateDisp(y, design)
  fit <- glmQLFit(y, design)
  fit <- glmQLFTest(fit, contrast = contrast)
  topTags(fit, n = Inf, sort.by = "none")$table %>% 
    dplyr::mutate(gene = rownames(.), cluster_id = k) %>% 
    dplyr::rename(p_val = PValue, p_adj = FDR)
})

# Results filtering & overview

# filter FDR < 0.05, |logFC| > 1 & sort by FDR
res_fil <- lapply(res, 
                  function(u)  u %>% 
                    dplyr::filter(p_adj < 0.05, abs(logFC) > 1) %>% 
                    dplyr::arrange(p_adj))


#Significant genes
# We filter the results with the criteria FDR < 0.05, and |logFC| > 1. 
# For each cluster we report the number of differentially expressed genes and what percentage that represents (of total genes).

## Count the number of differential findings by cluster.
# nb. & % of DE genes per cluster
n_de <- vapply(res_fil, nrow, numeric(1))
cbind(cluster=keepClusters, numDE_genes=n_de, 
      percentage = round(n_de / nrow(pbc) * 100, digits =2)) %>%  kable()

##Write results to file

for(cluster in 1:length(keepClusters)){
  # Full results
  filePath <- paste0("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/", keepClusters[cluster])
  out <- res[[cluster]][,c("gene", "logFC", "logCPM", "F", "p_val", "p_adj")]
  write.csv(out, file = paste0(filePath,"_", "D0D36_edgeR_pseudobulk_Allresults_240724_ALTERNATIVE.csv"), quote=F, row.names = F)
  
  # Sig genes
  filePath <- paste0("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/", keepClusters[cluster])
  out <- res_fil[[cluster]][,c("gene", "logFC", "logCPM", "F", "p_val", "p_adj")]
  write.csv(out, file = paste0(filePath,"_", "D0D36_edgeR_pseudobulk_sigGenes_240724_ALTERNATIVE.csv"), quote=F, row.names = F)
  
}

##Plotting results

##Combining all csv for significant genes into one
dir.create("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/sigGenes/")
files <- list.files(path = "/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/", pattern = "_sigGenes")
setwd("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/")
pbulkDe <- rbindlist(sapply(files, fread, simplify = FALSE), idcol = 'filename')
pbulkDe$filename <- gsub("Tfh1_CM", "Tfh1CM", pbulkDe$filename)
##Making new variables
separate(pbulkDe, filename, sep="_", into = c("cluster_name", "day", "V1", "V2", "V3", "V4", "V5"), remove = FALSE) -> pbulkDe1
#983 7
##Day variable
pbulkDe1$day <- ifelse (pbulkDe1$day == c("D0D8"), c("day8"), pbulkDe1$day)
pbulkDe1$day <- ifelse (pbulkDe1$day == c("D0D16"), c("day16"), pbulkDe1$day)
pbulkDe1$day <- ifelse (pbulkDe1$day == c("D0D36"), c("day36"), pbulkDe1$day)

#removing extra column
pbulkDe2 <- pbulkDe1[, c(2:3, 9:14)]

##saving to csv.
#getwd("D:/'OneDrive - Burnet Institute'/Seurat_analysis_test/IBSM_40/data/")
write.csv (pbulkDe2, "/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/sigGenes/psbulk_sigGens_all_DayClusters_080824.csv")

```

##### Reading input

```{r reading DE gene list for CHMI cohort, include=TRUE, warning=FALSE}
upset0 <-  read.csv(file="/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/sigGenes/psbulk_sigGens_all_DayClusters_080824.csv", row.names = 1)

##Getting dataset
##Input  
## Long format: gene, pval, logFC, cluster, day
## From pseudobulk analysis subset of genes with p_adj <0.005 and
## LogFC>abs(1)

upset1 <- upset0[,c(3,8,4,1,2)]
#Change colnames
colnames(upset1)[4] ="celltype"
colnames(upset1)[3] ="Log2FC"
colnames(upset1)[2] ="p_adj"

#reorder...
upset1$day <- factor(upset1$day, levels = c("day8", "day16", "day36"))
upset1$celltype <- factor(upset1$celltype, levels = c("Tfh1", "Tfh1CM", "Tfh2", "Tfh17", "Tfreg", "IFNI", "heatshock",
                                                     "ribo", "cluster2", "cluster3"))
```

#### Figure 5 A \| DEGs for each cluster were calculated at day 8, 16, and 36 compared to day 0. The number of DEGs for each subset and timepoint.

```{r Figure5A_DEGs for each cluster were calculated at day 8, 16, and 36 compared to day 0. The number of DEGs for each subset and timepoint., warning=FALSE, include=TRUE, fig.height= 4, fig.width=8, out.width="70%", fig.align='center'}
Tfh_colors_list <- c("#9e0142", "#f4a582", "#5e4fa2", "#66c2a5", "#74add1",
                     "#8c510a", "#bf812d", "#fee090", "#01665e", "#b2abd2")


# Create the bar plot with custom colors
ggplot(upset1, aes(x = celltype, fill = celltype)) +
  geom_bar() +  # Counts occurrences of each celltype
  facet_wrap(~ day) +  # Facet by day
  labs(x = "Cell Type", y = "No. of DEGs") +
  theme_classic() +  # Black-and-white theme
  scale_fill_manual(values = Tfh_colors_list) +  # Apply custom colors
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  # Rotate x-axis labels for readability
  scale_y_continuous(trans = "log10") 
```

#### Figure 5 B \| Venn diagram indicating the shared and unique DEGS at day 16 for Tfh1_cytotoxic, Tfh1_CCR7 and Tfh2 subsets.

```{r Figure5B_Venn diagram indicating the shared and unique DEGS at day 16 for Tfh1_cytotoxic, Tfh1_CCR7 and Tfh2 subsets, include=TRUE, warning=FALSE,fig.height= 4, fig.width=4, out.width="50%", fig.align='center'}
Tfh1_genecounts = sum(upset1$celltype=="Tfh1")
Tfh1CM_genecounts = sum(upset1$celltype=="Tfh1CM")
Tfh2_genecounts = sum(upset1$celltype=="Tfh2")
##intersections
Tfh1Genes <- upset1 %>% filter(celltype == "Tfh1") %>% pull(gene)
Tfh1CMGenes <- upset1 %>% filter(celltype == "Tfh1CM") %>% pull(gene)

Tfh1_n_Tfh1CM_genecounts <- length(intersect(Tfh1Genes, Tfh1CMGenes))

##intersections
Tfh1Genes <- upset1 %>% filter(celltype == "Tfh1") %>% pull(gene)
Tfh2Genes <- upset1 %>% filter(celltype == "Tfh2") %>% pull(gene)

Tfh1_n_Tfh2_genecounts <- length(intersect(Tfh1Genes, Tfh2Genes))
##intersections
Tfh1CM_n_Tfh2_genecounts <- length(intersect(Tfh1CMGenes, Tfh2Genes))
##intersections
Tfh1_n_Tfh1CM_n_Tfh2_genecounts <- length(intersect(intersect(Tfh1Genes, Tfh1CMGenes), Tfh2Genes))

# Input in the form of a named numeric vector
fit1 <- euler(c(
  "Tfh1" = Tfh1_genecounts,
  "Tfh1CM" = Tfh1CM_genecounts,
  "Tfh2" = Tfh2_genecounts,
  "Tfh1&Tfh1CM" = Tfh1_n_Tfh1CM_genecounts,
  "Tfh1&Tfh2" = Tfh1_n_Tfh2_genecounts,
  "Tfh1CM&Tfh2" = Tfh1CM_n_Tfh2_genecounts,
  "Tfh1&Tfh1CM&Tfh2" = Tfh1_n_Tfh1CM_n_Tfh2_genecounts
))

fill_colors <- c("#9e0142", "#fcc5c0", "#8c96c6")  # Replace with your desired colors

# Remove fills, vary borders, display quantities, and switch font.
plot(
  fit1,
  quantities = TRUE,
  fill = fill_colors,
  lty = 1, #solid lines for circles
  labels = list(font = 4)
)
```

#### Figure 5 C \| Expression of activation genes MKI67, CD38 and ICOS at day 16 in each Tfh subset compared to Day 0.

```{r Getting data for Figure5C, include=TRUE, echo=TRUE,warning=FALSE}
TfhIBSM <- readRDS("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/input/Tfh.IBSM.2_REANNOTATION_POSTNORM_V2_200724.rds")

Tfh.16 <- subset(TfhIBSM, subset = day == "day16")

DefaultAssay(Tfh.16)
```

```{r Figure5C_Expression of activation genes MKI67, CD38 and ICOS at day 16 in each Tfh subset compared to Day 0, include=TRUE, warning=FALSE,fig.height= 4, fig.width=4, out.width="50%", fig.align='center'}

log.data <- GetAssayData(Tfh.16[["RNA"]], layer = "data")
Tfh.16_b <- SetAssayData(Tfh.16,
                       layer = "data",
                       new.data = log.data,
                       assay = "RNA")

# Activation genes

Stacked_VlnPlot(Tfh.16_b, features = c("MKI67", "CD38", "ICOS"), x_lab_rotate = TRUE,
                group.by = "alternative_clusters", colors_use = Tfh_colors_list)

```

##### Getting data for Figure5D

```{r Getting data for Figure5D, warning=FALSE, include=TRUE, echo=TRUE}
#Tfh.IBSM <- readRDS(here("input/TfhIBSM_mappedtofullREF_reannotated_230523_v2.rds"))
TfhIBSM <- readRDS("/working_groups/boylelab/shared/ZulyPava/Tfh_diversity_finalcode/input/Tfh.IBSM.2_REANNOTATION_POSTNORM_V2_200724.rds")

TfhIBSM@meta.data$alternative_clusters <- factor(TfhIBSM@meta.data$alternative_clusters,
                                                 levels = c("Tfh1", "Tfh1_CM", "Tfh2", "Tfh17",
                                                            "Tfh1.17", "Tfreg", "IFNI",
                                                            "heatshock", "ribo", "cluster2",
                                                            "cluster3"))

## first we want to get a pseudobulk count matrix..

# renaming cluster for ease.. (you can skip this if you don't need)
TfhIBSM@meta.data$alternative_clusters <- gsub("Tfh1_CM", "Tfh1CM", TfhIBSM@meta.data$alternative_clusters, fixed = TRUE)

TfhIBSM@meta.data$donor_day_cluster <- paste(TfhIBSM@meta.data$donor_day, TfhIBSM@meta.data$alternative_clusters, sep = "_")

TfhIBSM@meta.data$donor_day_cluster <- factor(TfhIBSM@meta.data$donor_day_cluster)

# now getting pseudobulk counts by the combination I want: donor_day_cluster
DefaultAssay(TfhIBSM) <- "RNA"

TfhIBSM<- NormalizeData(TfhIBSM)

# this is right... you aggregate using raw counts... 
TfhIBSM.Average <- AggregateExpression(TfhIBSM, group.by = "donor_day_cluster", slot = "counts", assays = "RNA", return.seurat = T)

### tidying up metadata naming
TfhIBSM.Average@meta.data$donor_day_cluster <- as.factor(rownames(TfhIBSM.Average@meta.data))

# Split name column into firstname and last name
TfhIBSM.Average@meta.data[c("donor", "day", "seurat_clusters")] <- str_split_fixed(TfhIBSM.Average@meta.data$donor_day_cluster, "-", 3)

# Now extract the pseudobulked log-counts (NON-SCALED)    

TfhIBSM.scalemat <- GetAssayData(TfhIBSM.Average, layer = "data") # data is already log-normalised.. 

## put in metadata
TfhIBSM.meta <- as.data.frame(TfhIBSM.Average@meta.data)
TfhIBSM.scalemat <- as.data.frame(TfhIBSM.scalemat)
TfhIBSM.scalemat <- as.data.frame(t(TfhIBSM.scalemat))

TfhIBSM.scalemat$donor_day_cluster<- rownames(TfhIBSM.scalemat)


Average.df <- merge(x = TfhIBSM.scalemat, y = TfhIBSM.meta, by = "donor_day_cluster")

# Average.df <- read.csv("TfhIBSM_Averagemat_LOGNORMALISED_donordaycluster_V2_090824.csv", row.names = 1)
rownames(Average.df) <- Average.df$donor_day_cluster

Average.df$day <- factor(Average.df$day, levels = c("day0", "day8", "day16", "day36"))
Average.df$seurat_clusters <- factor(Average.df$seurat_clusters, levels = c("Tfh1", "Tfh1CM", "Tfh2", "Tfh17",
                                                                            "Tfreg", "IFNI",
                                                                            "heatshock", "ribo", "cluster2",
                                                                            "cluster3"))

### subset
Average.dfsub <- Average.df[Average.df$day == "day16", ]
Average.dfsub <- Average.dfsub[Average.dfsub$seurat_clusters %in% c("Tfh1", "Tfh1CM", "Tfh2"), ]


#### okay now to reorder EVERYTHING... 

my_order <- c("donor0-day16-Tfh1", "donor1-day16-Tfh1", "donor2-day16-Tfh1", "donor3-day16-Tfh1",
              "donor0-day16-Tfh1CM", "donor1-day16-Tfh1CM", "donor2-day16-Tfh1CM", "donor3-day16-Tfh1CM",
              "donor0-day16-Tfh2", "donor1-day16-Tfh2", "donor2-day16-Tfh2", "donor3-day16-Tfh2")

Average.dfsub <- Average.dfsub[match(my_order, rownames(Average.dfsub)), ]

### now reoreder everything else I want as well...
Average.dfsub$seurat_clusters <- factor(Average.dfsub$seurat_clusters, levels = c("Tfh1","Tfh1CM", "Tfh2"))
Average.dfsub$donor <- factor(Average.dfsub$donor, levels = c("donor0", "donor1", "donor2", "donor3"))

```


```{r import DEA gene list, }
### subset gene lists... 
colnames(upset1)[3] <- "logFC"
Tfh1CMgenes <- upset1%>%filter(celltype=="Tfh1CM", day== "day16")
Tfh1genes <- upset1%>%filter(celltype=="Tfh1", day== "day16")
Tfh2genes <- upset1%>%filter(celltype=="Tfh2", day== "day16")

# edgeR was done - D16 v D0, so logFC< 0 = up at d16, log FC >0 = down at d16, but up at day 0 
Tfh1CMgenes$dir_sig[Tfh1CMgenes$p_adj<0.05 & Tfh1CMgenes$logFC<0] <-"up"
Tfh1CMgenes$dir_sig[Tfh1CMgenes$p_adj<0.05 & Tfh1CMgenes$logFC>0] <-"down"
Tfh1genes$dir_sig[Tfh1genes$p_adj<0.05 & Tfh1genes$logFC<0] <-"up"
Tfh1genes$dir_sig[Tfh1genes$p_adj<0.05 & Tfh1genes$logFC>0] <-"down"
Tfh2genes$dir_sig[Tfh2genes$p_adj<0.05 & Tfh2genes$logFC<0] <-"up"
Tfh2genes$dir_sig[Tfh2genes$p_adj<0.05 & Tfh2genes$logFC>0] <-"down"

# let's get D16up - top 50
Tfh1CMgenes$logFC <- Tfh1CMgenes$logFC*-1
Tfh1CMgenes <- Tfh1CMgenes[order(Tfh1CMgenes$logFC, decreasing = TRUE),]
topCM <- head(Tfh1CMgenes, n=20)
Tfh1genes$logFC <- Tfh1genes$logFC*-1
Tfh1genes <- Tfh1genes[order(Tfh1genes$logFC, decreasing = TRUE),]
top1 <- head(Tfh1genes, n=20)
Tfh2genes$logFC <- Tfh2genes$logFC *-1
Tfh2genes <- Tfh2genes[order(Tfh2genes$logFC, decreasing = TRUE),]
top2 <- head(Tfh2genes, n=20)


# Extract gene columns and merge
merged_genes <- unique(c(topCM$gene, top1$gene, top2$gene))

# Ensure only the top 50 unique genes
merged_genes <- unique(merged_genes[1:50])

dfsub_16<- Average.dfsub[, colnames(Average.dfsub) %in% merged_genes]

dfsub_16 <- as.matrix(dfsub_16)
dfsub_16 = scale(dfsub_16)


col = list(Cluster = c("Tfh1" = "#b2182b", "Tfh1CM" = "#fbb4ae", "Tfh2" = "#6e016b"), 
           Donor = c("donor0" = "#cb7a88", "donor1" = "#ccab7b", "donor2" = "#a3cb7a", "donor3" = "#7cbecc"))

ha <- HeatmapAnnotation(Cluster=Average.dfsub$seurat_clusters,
                        Donor=Average.dfsub$donor,
                        col = col)
```

#### Figure 5 D \| Expression of top 50 unique upregulated genes for Tfh1_Cyto, Tfh1_CCR7 and Tfh2

```{r Figure5D, warning=FALSE, include=TRUE, echo=TRUE, fig.height=10, fig.width=6, out.width="70%", fig.align='center'}
Heatmap(t(dfsub_16),
        name = "RNAseq", col=mako(50),
        top_annotation = ha,
        cluster_rows = TRUE, cluster_columns = FALSE,
        column_title = "Genes", row_title = "Samples",
        row_names_gp = gpar(fontsize=6),
        column_names_gp = gpar(fontsize=4))
```
```{r session infor}
xfun::session_info(c("plyr", "tidyr", "dplyr", "Seurat", "patchwork", "ggplot2", "sctransform", 
  "BiocManager", "limma", "scCustomize", "qs", "viridis", "tidyverse", 
  "ggpubr", "scRepertoire", "data.table", "gtools", "ggraph", "tibble", 
  "circlize", "ggalluvial", "RColorBrewer", "rstackdeque", "ComplexHeatmap", 
  "harmony", "openxlsx", "HGNChelper", "pheatmap", "forcats", "ggthemes", 
  "ggrepel", "cowplot", "ggfortify", "gplots", "reshape2", "rstatix", "eulerr"), dependencies = FALSE)
```
